// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: annotatedvalue.proto

package annotatedvalue // import "github.com/AljabrIO/koalja-operator/pkg/annotatedvalue"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import types "github.com/gogo/protobuf/types"
import empty "github.com/golang/protobuf/ptypes/empty"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type CanPublishRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CanPublishRequest) Reset()         { *m = CanPublishRequest{} }
func (m *CanPublishRequest) String() string { return proto.CompactTextString(m) }
func (*CanPublishRequest) ProtoMessage()    {}
func (*CanPublishRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotatedvalue_32e9cdee10a37494, []int{0}
}
func (m *CanPublishRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CanPublishRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CanPublishRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CanPublishRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CanPublishRequest.Merge(dst, src)
}
func (m *CanPublishRequest) XXX_Size() int {
	return m.Size()
}
func (m *CanPublishRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CanPublishRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CanPublishRequest proto.InternalMessageInfo

type CanPublishResponse struct {
	// Allowed is true calls to Publish are allowed, false otherwise.
	Allowed              bool     `protobuf:"varint,1,opt,name=Allowed,json=allowed,proto3" json:"Allowed,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CanPublishResponse) Reset()         { *m = CanPublishResponse{} }
func (m *CanPublishResponse) String() string { return proto.CompactTextString(m) }
func (*CanPublishResponse) ProtoMessage()    {}
func (*CanPublishResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotatedvalue_32e9cdee10a37494, []int{1}
}
func (m *CanPublishResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CanPublishResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CanPublishResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CanPublishResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CanPublishResponse.Merge(dst, src)
}
func (m *CanPublishResponse) XXX_Size() int {
	return m.Size()
}
func (m *CanPublishResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CanPublishResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CanPublishResponse proto.InternalMessageInfo

func (m *CanPublishResponse) GetAllowed() bool {
	if m != nil {
		return m.Allowed
	}
	return false
}

type PublishRequest struct {
	AnnotatedValue       *AnnotatedValue `protobuf:"bytes,1,opt,name=AnnotatedValue,json=annotatedValue" json:"AnnotatedValue,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *PublishRequest) Reset()         { *m = PublishRequest{} }
func (m *PublishRequest) String() string { return proto.CompactTextString(m) }
func (*PublishRequest) ProtoMessage()    {}
func (*PublishRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotatedvalue_32e9cdee10a37494, []int{2}
}
func (m *PublishRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublishRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PublishRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PublishRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublishRequest.Merge(dst, src)
}
func (m *PublishRequest) XXX_Size() int {
	return m.Size()
}
func (m *PublishRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PublishRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PublishRequest proto.InternalMessageInfo

func (m *PublishRequest) GetAnnotatedValue() *AnnotatedValue {
	if m != nil {
		return m.AnnotatedValue
	}
	return nil
}

type PublishResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PublishResponse) Reset()         { *m = PublishResponse{} }
func (m *PublishResponse) String() string { return proto.CompactTextString(m) }
func (*PublishResponse) ProtoMessage()    {}
func (*PublishResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotatedvalue_32e9cdee10a37494, []int{3}
}
func (m *PublishResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublishResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PublishResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PublishResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublishResponse.Merge(dst, src)
}
func (m *PublishResponse) XXX_Size() int {
	return m.Size()
}
func (m *PublishResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PublishResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PublishResponse proto.InternalMessageInfo

type SubscribeRequest struct {
	ClientID             string   `protobuf:"bytes,1,opt,name=ClientID,json=clientID,proto3" json:"ClientID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubscribeRequest) Reset()         { *m = SubscribeRequest{} }
func (m *SubscribeRequest) String() string { return proto.CompactTextString(m) }
func (*SubscribeRequest) ProtoMessage()    {}
func (*SubscribeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotatedvalue_32e9cdee10a37494, []int{4}
}
func (m *SubscribeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscribeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscribeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SubscribeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeRequest.Merge(dst, src)
}
func (m *SubscribeRequest) XXX_Size() int {
	return m.Size()
}
func (m *SubscribeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeRequest proto.InternalMessageInfo

func (m *SubscribeRequest) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

type Subscription struct {
	ID                   int64    `protobuf:"varint,1,opt,name=ID,json=iD,proto3" json:"ID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Subscription) Reset()         { *m = Subscription{} }
func (m *Subscription) String() string { return proto.CompactTextString(m) }
func (*Subscription) ProtoMessage()    {}
func (*Subscription) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotatedvalue_32e9cdee10a37494, []int{5}
}
func (m *Subscription) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Subscription) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Subscription.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Subscription) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Subscription.Merge(dst, src)
}
func (m *Subscription) XXX_Size() int {
	return m.Size()
}
func (m *Subscription) XXX_DiscardUnknown() {
	xxx_messageInfo_Subscription.DiscardUnknown(m)
}

var xxx_messageInfo_Subscription proto.InternalMessageInfo

func (m *Subscription) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

type SubscribeResponse struct {
	Subscription         *Subscription   `protobuf:"bytes,1,opt,name=Subscription,json=subscription" json:"Subscription,omitempty"`
	TTL                  *types.Duration `protobuf:"bytes,2,opt,name=TTL,json=tTL" json:"TTL,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *SubscribeResponse) Reset()         { *m = SubscribeResponse{} }
func (m *SubscribeResponse) String() string { return proto.CompactTextString(m) }
func (*SubscribeResponse) ProtoMessage()    {}
func (*SubscribeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotatedvalue_32e9cdee10a37494, []int{6}
}
func (m *SubscribeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscribeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscribeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SubscribeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeResponse.Merge(dst, src)
}
func (m *SubscribeResponse) XXX_Size() int {
	return m.Size()
}
func (m *SubscribeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeResponse proto.InternalMessageInfo

func (m *SubscribeResponse) GetSubscription() *Subscription {
	if m != nil {
		return m.Subscription
	}
	return nil
}

func (m *SubscribeResponse) GetTTL() *types.Duration {
	if m != nil {
		return m.TTL
	}
	return nil
}

type PingRequest struct {
	Subscription         *Subscription `protobuf:"bytes,1,opt,name=Subscription,json=subscription" json:"Subscription,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *PingRequest) Reset()         { *m = PingRequest{} }
func (m *PingRequest) String() string { return proto.CompactTextString(m) }
func (*PingRequest) ProtoMessage()    {}
func (*PingRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotatedvalue_32e9cdee10a37494, []int{7}
}
func (m *PingRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PingRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PingRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PingRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PingRequest.Merge(dst, src)
}
func (m *PingRequest) XXX_Size() int {
	return m.Size()
}
func (m *PingRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PingRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PingRequest proto.InternalMessageInfo

func (m *PingRequest) GetSubscription() *Subscription {
	if m != nil {
		return m.Subscription
	}
	return nil
}

type CloseRequest struct {
	Subscription         *Subscription `protobuf:"bytes,1,opt,name=Subscription,json=subscription" json:"Subscription,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *CloseRequest) Reset()         { *m = CloseRequest{} }
func (m *CloseRequest) String() string { return proto.CompactTextString(m) }
func (*CloseRequest) ProtoMessage()    {}
func (*CloseRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotatedvalue_32e9cdee10a37494, []int{8}
}
func (m *CloseRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloseRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloseRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CloseRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloseRequest.Merge(dst, src)
}
func (m *CloseRequest) XXX_Size() int {
	return m.Size()
}
func (m *CloseRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CloseRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CloseRequest proto.InternalMessageInfo

func (m *CloseRequest) GetSubscription() *Subscription {
	if m != nil {
		return m.Subscription
	}
	return nil
}

type NextRequest struct {
	Subscription         *Subscription   `protobuf:"bytes,1,opt,name=Subscription,json=subscription" json:"Subscription,omitempty"`
	WaitTimeout          *types.Duration `protobuf:"bytes,2,opt,name=WaitTimeout,json=waitTimeout" json:"WaitTimeout,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *NextRequest) Reset()         { *m = NextRequest{} }
func (m *NextRequest) String() string { return proto.CompactTextString(m) }
func (*NextRequest) ProtoMessage()    {}
func (*NextRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotatedvalue_32e9cdee10a37494, []int{9}
}
func (m *NextRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NextRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NextRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *NextRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NextRequest.Merge(dst, src)
}
func (m *NextRequest) XXX_Size() int {
	return m.Size()
}
func (m *NextRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NextRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NextRequest proto.InternalMessageInfo

func (m *NextRequest) GetSubscription() *Subscription {
	if m != nil {
		return m.Subscription
	}
	return nil
}

func (m *NextRequest) GetWaitTimeout() *types.Duration {
	if m != nil {
		return m.WaitTimeout
	}
	return nil
}

type NextResponse struct {
	AnnotatedValue       *AnnotatedValue `protobuf:"bytes,1,opt,name=AnnotatedValue,json=annotatedValue" json:"AnnotatedValue,omitempty"`
	NoAnnotatedValueYet  bool            `protobuf:"varint,2,opt,name=NoAnnotatedValueYet,json=noAnnotatedValueYet,proto3" json:"NoAnnotatedValueYet,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *NextResponse) Reset()         { *m = NextResponse{} }
func (m *NextResponse) String() string { return proto.CompactTextString(m) }
func (*NextResponse) ProtoMessage()    {}
func (*NextResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotatedvalue_32e9cdee10a37494, []int{10}
}
func (m *NextResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NextResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NextResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *NextResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NextResponse.Merge(dst, src)
}
func (m *NextResponse) XXX_Size() int {
	return m.Size()
}
func (m *NextResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NextResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NextResponse proto.InternalMessageInfo

func (m *NextResponse) GetAnnotatedValue() *AnnotatedValue {
	if m != nil {
		return m.AnnotatedValue
	}
	return nil
}

func (m *NextResponse) GetNoAnnotatedValueYet() bool {
	if m != nil {
		return m.NoAnnotatedValueYet
	}
	return false
}

type AckRequest struct {
	Subscription         *Subscription `protobuf:"bytes,1,opt,name=Subscription,json=subscription" json:"Subscription,omitempty"`
	AnnotatedValueID     string        `protobuf:"bytes,2,opt,name=AnnotatedValueID,json=annotatedValueID,proto3" json:"AnnotatedValueID,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *AckRequest) Reset()         { *m = AckRequest{} }
func (m *AckRequest) String() string { return proto.CompactTextString(m) }
func (*AckRequest) ProtoMessage()    {}
func (*AckRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotatedvalue_32e9cdee10a37494, []int{11}
}
func (m *AckRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AckRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AckRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AckRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AckRequest.Merge(dst, src)
}
func (m *AckRequest) XXX_Size() int {
	return m.Size()
}
func (m *AckRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AckRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AckRequest proto.InternalMessageInfo

func (m *AckRequest) GetSubscription() *Subscription {
	if m != nil {
		return m.Subscription
	}
	return nil
}

func (m *AckRequest) GetAnnotatedValueID() string {
	if m != nil {
		return m.AnnotatedValueID
	}
	return ""
}

type AnnotatedValue struct {
	// ID is a unique ID of this annotated value
	ID string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// SourceTask contains the URI of the task that created the annotated value
	SourceTask string `protobuf:"bytes,2,opt,name=source_task,json=sourceTask,proto3" json:"source_task,omitempty"`
	// SourceTaskOutput contains the name of the output of the task that created the annotated value
	SourceTaskOutput string `protobuf:"bytes,3,opt,name=source_task_output,json=sourceTaskOutput,proto3" json:"source_task_output,omitempty"`
	// Link contains the URI of the Link that published the annotated value
	Link string `protobuf:"bytes,4,opt,name=link,proto3" json:"link,omitempty"`
	// SourceInputs contains zero or more URI's of annotated values sequences that resulted in this annotated value
	SourceInputs []*AnnotatedValueSourceInput `protobuf:"bytes,5,rep,name=source_inputs,json=sourceInputs" json:"source_inputs,omitempty"`
	// Data contains a URI of the data (payload) of the message
	Data string `protobuf:"bytes,6,opt,name=data,proto3" json:"data,omitempty"`
	// CreatedAt is the creation timestamp of the annotated value
	CreatedAt            *types.Timestamp `protobuf:"bytes,7,opt,name=created_at,json=createdAt" json:"created_at,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *AnnotatedValue) Reset()         { *m = AnnotatedValue{} }
func (m *AnnotatedValue) String() string { return proto.CompactTextString(m) }
func (*AnnotatedValue) ProtoMessage()    {}
func (*AnnotatedValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotatedvalue_32e9cdee10a37494, []int{12}
}
func (m *AnnotatedValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnnotatedValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnnotatedValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AnnotatedValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnnotatedValue.Merge(dst, src)
}
func (m *AnnotatedValue) XXX_Size() int {
	return m.Size()
}
func (m *AnnotatedValue) XXX_DiscardUnknown() {
	xxx_messageInfo_AnnotatedValue.DiscardUnknown(m)
}

var xxx_messageInfo_AnnotatedValue proto.InternalMessageInfo

func (m *AnnotatedValue) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *AnnotatedValue) GetSourceTask() string {
	if m != nil {
		return m.SourceTask
	}
	return ""
}

func (m *AnnotatedValue) GetSourceTaskOutput() string {
	if m != nil {
		return m.SourceTaskOutput
	}
	return ""
}

func (m *AnnotatedValue) GetLink() string {
	if m != nil {
		return m.Link
	}
	return ""
}

func (m *AnnotatedValue) GetSourceInputs() []*AnnotatedValueSourceInput {
	if m != nil {
		return m.SourceInputs
	}
	return nil
}

func (m *AnnotatedValue) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *AnnotatedValue) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

type AnnotatedValueSourceInput struct {
	// IDs of the all annotated values in the source sequence
	IDs []string `protobuf:"bytes,1,rep,name=ids" json:"ids,omitempty"`
	// Name of the task input on which this sequence of annotated values came in
	InputName            string   `protobuf:"bytes,2,opt,name=input_name,json=inputName,proto3" json:"input_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AnnotatedValueSourceInput) Reset()         { *m = AnnotatedValueSourceInput{} }
func (m *AnnotatedValueSourceInput) String() string { return proto.CompactTextString(m) }
func (*AnnotatedValueSourceInput) ProtoMessage()    {}
func (*AnnotatedValueSourceInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotatedvalue_32e9cdee10a37494, []int{13}
}
func (m *AnnotatedValueSourceInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnnotatedValueSourceInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnnotatedValueSourceInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AnnotatedValueSourceInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnnotatedValueSourceInput.Merge(dst, src)
}
func (m *AnnotatedValueSourceInput) XXX_Size() int {
	return m.Size()
}
func (m *AnnotatedValueSourceInput) XXX_DiscardUnknown() {
	xxx_messageInfo_AnnotatedValueSourceInput.DiscardUnknown(m)
}

var xxx_messageInfo_AnnotatedValueSourceInput proto.InternalMessageInfo

func (m *AnnotatedValueSourceInput) GetIDs() []string {
	if m != nil {
		return m.IDs
	}
	return nil
}

func (m *AnnotatedValueSourceInput) GetInputName() string {
	if m != nil {
		return m.InputName
	}
	return ""
}

type GetByIDRequest struct {
	ID                   string   `protobuf:"bytes,1,opt,name=ID,json=iD,proto3" json:"ID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetByIDRequest) Reset()         { *m = GetByIDRequest{} }
func (m *GetByIDRequest) String() string { return proto.CompactTextString(m) }
func (*GetByIDRequest) ProtoMessage()    {}
func (*GetByIDRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotatedvalue_32e9cdee10a37494, []int{14}
}
func (m *GetByIDRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetByIDRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetByIDRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetByIDRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetByIDRequest.Merge(dst, src)
}
func (m *GetByIDRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetByIDRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetByIDRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetByIDRequest proto.InternalMessageInfo

func (m *GetByIDRequest) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

type GetByTaskAndDataRequest struct {
	SourceTask           string   `protobuf:"bytes,1,opt,name=SourceTask,json=sourceTask,proto3" json:"SourceTask,omitempty"`
	Data                 string   `protobuf:"bytes,2,opt,name=Data,json=data,proto3" json:"Data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetByTaskAndDataRequest) Reset()         { *m = GetByTaskAndDataRequest{} }
func (m *GetByTaskAndDataRequest) String() string { return proto.CompactTextString(m) }
func (*GetByTaskAndDataRequest) ProtoMessage()    {}
func (*GetByTaskAndDataRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotatedvalue_32e9cdee10a37494, []int{15}
}
func (m *GetByTaskAndDataRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetByTaskAndDataRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetByTaskAndDataRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetByTaskAndDataRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetByTaskAndDataRequest.Merge(dst, src)
}
func (m *GetByTaskAndDataRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetByTaskAndDataRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetByTaskAndDataRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetByTaskAndDataRequest proto.InternalMessageInfo

func (m *GetByTaskAndDataRequest) GetSourceTask() string {
	if m != nil {
		return m.SourceTask
	}
	return ""
}

func (m *GetByTaskAndDataRequest) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

type GetRequest struct {
	// If set, filter on any of these IDs
	IDs []string `protobuf:"bytes,1,rep,name=IDs,json=iDs" json:"IDs,omitempty"`
	// If set, filter on any of these source task names.
	SourceTasks []string `protobuf:"bytes,2,rep,name=SourceTasks,json=sourceTasks" json:"SourceTasks,omitempty"`
	// If set, filter on any of these data values.
	Data []string `protobuf:"bytes,3,rep,name=Data,json=data" json:"Data,omitempty"`
	// If set, filter on values created after this timestamp.
	CreatedAfter *types.Timestamp `protobuf:"bytes,4,opt,name=CreatedAfter,json=createdAfter" json:"CreatedAfter,omitempty"`
	// If set, filter on values created before this timestamp.
	CreatedBefore *types.Timestamp `protobuf:"bytes,5,opt,name=CreatedBefore,json=createdBefore" json:"CreatedBefore,omitempty"`
	// If set, limit the number of selected values.
	Limit                int64    `protobuf:"varint,6,opt,name=Limit,json=limit,proto3" json:"Limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetRequest) Reset()         { *m = GetRequest{} }
func (m *GetRequest) String() string { return proto.CompactTextString(m) }
func (*GetRequest) ProtoMessage()    {}
func (*GetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotatedvalue_32e9cdee10a37494, []int{16}
}
func (m *GetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRequest.Merge(dst, src)
}
func (m *GetRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetRequest proto.InternalMessageInfo

func (m *GetRequest) GetIDs() []string {
	if m != nil {
		return m.IDs
	}
	return nil
}

func (m *GetRequest) GetSourceTasks() []string {
	if m != nil {
		return m.SourceTasks
	}
	return nil
}

func (m *GetRequest) GetData() []string {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *GetRequest) GetCreatedAfter() *types.Timestamp {
	if m != nil {
		return m.CreatedAfter
	}
	return nil
}

func (m *GetRequest) GetCreatedBefore() *types.Timestamp {
	if m != nil {
		return m.CreatedBefore
	}
	return nil
}

func (m *GetRequest) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type GetOneResponse struct {
	AnnotatedValue       *AnnotatedValue `protobuf:"bytes,1,opt,name=AnnotatedValue,json=annotatedValue" json:"AnnotatedValue,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *GetOneResponse) Reset()         { *m = GetOneResponse{} }
func (m *GetOneResponse) String() string { return proto.CompactTextString(m) }
func (*GetOneResponse) ProtoMessage()    {}
func (*GetOneResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotatedvalue_32e9cdee10a37494, []int{17}
}
func (m *GetOneResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetOneResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetOneResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetOneResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetOneResponse.Merge(dst, src)
}
func (m *GetOneResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetOneResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetOneResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetOneResponse proto.InternalMessageInfo

func (m *GetOneResponse) GetAnnotatedValue() *AnnotatedValue {
	if m != nil {
		return m.AnnotatedValue
	}
	return nil
}

type GetResponse struct {
	AnnotatedValues      []*AnnotatedValue `protobuf:"bytes,1,rep,name=AnnotatedValues,json=annotatedValues" json:"AnnotatedValues,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *GetResponse) Reset()         { *m = GetResponse{} }
func (m *GetResponse) String() string { return proto.CompactTextString(m) }
func (*GetResponse) ProtoMessage()    {}
func (*GetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotatedvalue_32e9cdee10a37494, []int{18}
}
func (m *GetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetResponse.Merge(dst, src)
}
func (m *GetResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetResponse proto.InternalMessageInfo

func (m *GetResponse) GetAnnotatedValues() []*AnnotatedValue {
	if m != nil {
		return m.AnnotatedValues
	}
	return nil
}

func init() {
	proto.RegisterType((*CanPublishRequest)(nil), "annotatedvalue.CanPublishRequest")
	proto.RegisterType((*CanPublishResponse)(nil), "annotatedvalue.CanPublishResponse")
	proto.RegisterType((*PublishRequest)(nil), "annotatedvalue.PublishRequest")
	proto.RegisterType((*PublishResponse)(nil), "annotatedvalue.PublishResponse")
	proto.RegisterType((*SubscribeRequest)(nil), "annotatedvalue.SubscribeRequest")
	proto.RegisterType((*Subscription)(nil), "annotatedvalue.Subscription")
	proto.RegisterType((*SubscribeResponse)(nil), "annotatedvalue.SubscribeResponse")
	proto.RegisterType((*PingRequest)(nil), "annotatedvalue.PingRequest")
	proto.RegisterType((*CloseRequest)(nil), "annotatedvalue.CloseRequest")
	proto.RegisterType((*NextRequest)(nil), "annotatedvalue.NextRequest")
	proto.RegisterType((*NextResponse)(nil), "annotatedvalue.NextResponse")
	proto.RegisterType((*AckRequest)(nil), "annotatedvalue.AckRequest")
	proto.RegisterType((*AnnotatedValue)(nil), "annotatedvalue.AnnotatedValue")
	proto.RegisterType((*AnnotatedValueSourceInput)(nil), "annotatedvalue.AnnotatedValueSourceInput")
	proto.RegisterType((*GetByIDRequest)(nil), "annotatedvalue.GetByIDRequest")
	proto.RegisterType((*GetByTaskAndDataRequest)(nil), "annotatedvalue.GetByTaskAndDataRequest")
	proto.RegisterType((*GetRequest)(nil), "annotatedvalue.GetRequest")
	proto.RegisterType((*GetOneResponse)(nil), "annotatedvalue.GetOneResponse")
	proto.RegisterType((*GetResponse)(nil), "annotatedvalue.GetResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AnnotatedValuePublisherClient is the client API for AnnotatedValuePublisher service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AnnotatedValuePublisherClient interface {
	// CanPublish returns true if publishing annotated values is allowed.
	CanPublish(ctx context.Context, in *CanPublishRequest, opts ...grpc.CallOption) (*CanPublishResponse, error)
	// Publish a given annotated value (into a link)
	Publish(ctx context.Context, in *PublishRequest, opts ...grpc.CallOption) (*PublishResponse, error)
}

type annotatedValuePublisherClient struct {
	cc *grpc.ClientConn
}

func NewAnnotatedValuePublisherClient(cc *grpc.ClientConn) AnnotatedValuePublisherClient {
	return &annotatedValuePublisherClient{cc}
}

func (c *annotatedValuePublisherClient) CanPublish(ctx context.Context, in *CanPublishRequest, opts ...grpc.CallOption) (*CanPublishResponse, error) {
	out := new(CanPublishResponse)
	err := c.cc.Invoke(ctx, "/annotatedvalue.AnnotatedValuePublisher/CanPublish", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *annotatedValuePublisherClient) Publish(ctx context.Context, in *PublishRequest, opts ...grpc.CallOption) (*PublishResponse, error) {
	out := new(PublishResponse)
	err := c.cc.Invoke(ctx, "/annotatedvalue.AnnotatedValuePublisher/Publish", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AnnotatedValuePublisherServer is the server API for AnnotatedValuePublisher service.
type AnnotatedValuePublisherServer interface {
	// CanPublish returns true if publishing annotated values is allowed.
	CanPublish(context.Context, *CanPublishRequest) (*CanPublishResponse, error)
	// Publish a given annotated value (into a link)
	Publish(context.Context, *PublishRequest) (*PublishResponse, error)
}

func RegisterAnnotatedValuePublisherServer(s *grpc.Server, srv AnnotatedValuePublisherServer) {
	s.RegisterService(&_AnnotatedValuePublisher_serviceDesc, srv)
}

func _AnnotatedValuePublisher_CanPublish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CanPublishRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnnotatedValuePublisherServer).CanPublish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/annotatedvalue.AnnotatedValuePublisher/CanPublish",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnnotatedValuePublisherServer).CanPublish(ctx, req.(*CanPublishRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnnotatedValuePublisher_Publish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnnotatedValuePublisherServer).Publish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/annotatedvalue.AnnotatedValuePublisher/Publish",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnnotatedValuePublisherServer).Publish(ctx, req.(*PublishRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _AnnotatedValuePublisher_serviceDesc = grpc.ServiceDesc{
	ServiceName: "annotatedvalue.AnnotatedValuePublisher",
	HandlerType: (*AnnotatedValuePublisherServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CanPublish",
			Handler:    _AnnotatedValuePublisher_CanPublish_Handler,
		},
		{
			MethodName: "Publish",
			Handler:    _AnnotatedValuePublisher_Publish_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "annotatedvalue.proto",
}

// AnnotatedValueSourceClient is the client API for AnnotatedValueSource service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AnnotatedValueSourceClient interface {
	// Subscribe to annotated values
	Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (*SubscribeResponse, error)
	// Ping keeps a subscription alive
	Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// Close a subscription
	Close(ctx context.Context, in *CloseRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// Ask for the next annotated value on a subscription
	Next(ctx context.Context, in *NextRequest, opts ...grpc.CallOption) (*NextResponse, error)
	// Acknowledge the processing of an annotated value
	Ack(ctx context.Context, in *AckRequest, opts ...grpc.CallOption) (*empty.Empty, error)
}

type annotatedValueSourceClient struct {
	cc *grpc.ClientConn
}

func NewAnnotatedValueSourceClient(cc *grpc.ClientConn) AnnotatedValueSourceClient {
	return &annotatedValueSourceClient{cc}
}

func (c *annotatedValueSourceClient) Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (*SubscribeResponse, error) {
	out := new(SubscribeResponse)
	err := c.cc.Invoke(ctx, "/annotatedvalue.AnnotatedValueSource/Subscribe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *annotatedValueSourceClient) Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/annotatedvalue.AnnotatedValueSource/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *annotatedValueSourceClient) Close(ctx context.Context, in *CloseRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/annotatedvalue.AnnotatedValueSource/Close", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *annotatedValueSourceClient) Next(ctx context.Context, in *NextRequest, opts ...grpc.CallOption) (*NextResponse, error) {
	out := new(NextResponse)
	err := c.cc.Invoke(ctx, "/annotatedvalue.AnnotatedValueSource/Next", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *annotatedValueSourceClient) Ack(ctx context.Context, in *AckRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/annotatedvalue.AnnotatedValueSource/Ack", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AnnotatedValueSourceServer is the server API for AnnotatedValueSource service.
type AnnotatedValueSourceServer interface {
	// Subscribe to annotated values
	Subscribe(context.Context, *SubscribeRequest) (*SubscribeResponse, error)
	// Ping keeps a subscription alive
	Ping(context.Context, *PingRequest) (*empty.Empty, error)
	// Close a subscription
	Close(context.Context, *CloseRequest) (*empty.Empty, error)
	// Ask for the next annotated value on a subscription
	Next(context.Context, *NextRequest) (*NextResponse, error)
	// Acknowledge the processing of an annotated value
	Ack(context.Context, *AckRequest) (*empty.Empty, error)
}

func RegisterAnnotatedValueSourceServer(s *grpc.Server, srv AnnotatedValueSourceServer) {
	s.RegisterService(&_AnnotatedValueSource_serviceDesc, srv)
}

func _AnnotatedValueSource_Subscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnnotatedValueSourceServer).Subscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/annotatedvalue.AnnotatedValueSource/Subscribe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnnotatedValueSourceServer).Subscribe(ctx, req.(*SubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnnotatedValueSource_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnnotatedValueSourceServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/annotatedvalue.AnnotatedValueSource/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnnotatedValueSourceServer).Ping(ctx, req.(*PingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnnotatedValueSource_Close_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnnotatedValueSourceServer).Close(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/annotatedvalue.AnnotatedValueSource/Close",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnnotatedValueSourceServer).Close(ctx, req.(*CloseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnnotatedValueSource_Next_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NextRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnnotatedValueSourceServer).Next(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/annotatedvalue.AnnotatedValueSource/Next",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnnotatedValueSourceServer).Next(ctx, req.(*NextRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnnotatedValueSource_Ack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnnotatedValueSourceServer).Ack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/annotatedvalue.AnnotatedValueSource/Ack",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnnotatedValueSourceServer).Ack(ctx, req.(*AckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _AnnotatedValueSource_serviceDesc = grpc.ServiceDesc{
	ServiceName: "annotatedvalue.AnnotatedValueSource",
	HandlerType: (*AnnotatedValueSourceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Subscribe",
			Handler:    _AnnotatedValueSource_Subscribe_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _AnnotatedValueSource_Ping_Handler,
		},
		{
			MethodName: "Close",
			Handler:    _AnnotatedValueSource_Close_Handler,
		},
		{
			MethodName: "Next",
			Handler:    _AnnotatedValueSource_Next_Handler,
		},
		{
			MethodName: "Ack",
			Handler:    _AnnotatedValueSource_Ack_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "annotatedvalue.proto",
}

// AnnotatedValueRegistryClient is the client API for AnnotatedValueRegistry service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AnnotatedValueRegistryClient interface {
	// Record the given annotated value in the registry
	Record(ctx context.Context, in *AnnotatedValue, opts ...grpc.CallOption) (*empty.Empty, error)
	// GetByID returns the annotated value with given ID.
	GetByID(ctx context.Context, in *GetByIDRequest, opts ...grpc.CallOption) (*GetOneResponse, error)
	// GetByTaskAndData returns the annotated value with given task & data.
	GetByTaskAndData(ctx context.Context, in *GetByTaskAndDataRequest, opts ...grpc.CallOption) (*GetOneResponse, error)
	// Get returns the annotated values that match the given criteria.
	Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error)
}

type annotatedValueRegistryClient struct {
	cc *grpc.ClientConn
}

func NewAnnotatedValueRegistryClient(cc *grpc.ClientConn) AnnotatedValueRegistryClient {
	return &annotatedValueRegistryClient{cc}
}

func (c *annotatedValueRegistryClient) Record(ctx context.Context, in *AnnotatedValue, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/annotatedvalue.AnnotatedValueRegistry/Record", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *annotatedValueRegistryClient) GetByID(ctx context.Context, in *GetByIDRequest, opts ...grpc.CallOption) (*GetOneResponse, error) {
	out := new(GetOneResponse)
	err := c.cc.Invoke(ctx, "/annotatedvalue.AnnotatedValueRegistry/GetByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *annotatedValueRegistryClient) GetByTaskAndData(ctx context.Context, in *GetByTaskAndDataRequest, opts ...grpc.CallOption) (*GetOneResponse, error) {
	out := new(GetOneResponse)
	err := c.cc.Invoke(ctx, "/annotatedvalue.AnnotatedValueRegistry/GetByTaskAndData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *annotatedValueRegistryClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	out := new(GetResponse)
	err := c.cc.Invoke(ctx, "/annotatedvalue.AnnotatedValueRegistry/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AnnotatedValueRegistryServer is the server API for AnnotatedValueRegistry service.
type AnnotatedValueRegistryServer interface {
	// Record the given annotated value in the registry
	Record(context.Context, *AnnotatedValue) (*empty.Empty, error)
	// GetByID returns the annotated value with given ID.
	GetByID(context.Context, *GetByIDRequest) (*GetOneResponse, error)
	// GetByTaskAndData returns the annotated value with given task & data.
	GetByTaskAndData(context.Context, *GetByTaskAndDataRequest) (*GetOneResponse, error)
	// Get returns the annotated values that match the given criteria.
	Get(context.Context, *GetRequest) (*GetResponse, error)
}

func RegisterAnnotatedValueRegistryServer(s *grpc.Server, srv AnnotatedValueRegistryServer) {
	s.RegisterService(&_AnnotatedValueRegistry_serviceDesc, srv)
}

func _AnnotatedValueRegistry_Record_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnnotatedValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnnotatedValueRegistryServer).Record(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/annotatedvalue.AnnotatedValueRegistry/Record",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnnotatedValueRegistryServer).Record(ctx, req.(*AnnotatedValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnnotatedValueRegistry_GetByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnnotatedValueRegistryServer).GetByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/annotatedvalue.AnnotatedValueRegistry/GetByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnnotatedValueRegistryServer).GetByID(ctx, req.(*GetByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnnotatedValueRegistry_GetByTaskAndData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByTaskAndDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnnotatedValueRegistryServer).GetByTaskAndData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/annotatedvalue.AnnotatedValueRegistry/GetByTaskAndData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnnotatedValueRegistryServer).GetByTaskAndData(ctx, req.(*GetByTaskAndDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnnotatedValueRegistry_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnnotatedValueRegistryServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/annotatedvalue.AnnotatedValueRegistry/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnnotatedValueRegistryServer).Get(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _AnnotatedValueRegistry_serviceDesc = grpc.ServiceDesc{
	ServiceName: "annotatedvalue.AnnotatedValueRegistry",
	HandlerType: (*AnnotatedValueRegistryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Record",
			Handler:    _AnnotatedValueRegistry_Record_Handler,
		},
		{
			MethodName: "GetByID",
			Handler:    _AnnotatedValueRegistry_GetByID_Handler,
		},
		{
			MethodName: "GetByTaskAndData",
			Handler:    _AnnotatedValueRegistry_GetByTaskAndData_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _AnnotatedValueRegistry_Get_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "annotatedvalue.proto",
}

func (m *CanPublishRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CanPublishRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CanPublishResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CanPublishResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Allowed {
		dAtA[i] = 0x8
		i++
		if m.Allowed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PublishRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublishRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AnnotatedValue != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAnnotatedvalue(dAtA, i, uint64(m.AnnotatedValue.Size()))
		n1, err := m.AnnotatedValue.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PublishResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublishResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SubscribeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscribeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClientID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAnnotatedvalue(dAtA, i, uint64(len(m.ClientID)))
		i += copy(dAtA[i:], m.ClientID)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Subscription) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Subscription) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAnnotatedvalue(dAtA, i, uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SubscribeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscribeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Subscription != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAnnotatedvalue(dAtA, i, uint64(m.Subscription.Size()))
		n2, err := m.Subscription.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.TTL != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAnnotatedvalue(dAtA, i, uint64(m.TTL.Size()))
		n3, err := m.TTL.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PingRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PingRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Subscription != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAnnotatedvalue(dAtA, i, uint64(m.Subscription.Size()))
		n4, err := m.Subscription.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CloseRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloseRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Subscription != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAnnotatedvalue(dAtA, i, uint64(m.Subscription.Size()))
		n5, err := m.Subscription.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NextRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NextRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Subscription != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAnnotatedvalue(dAtA, i, uint64(m.Subscription.Size()))
		n6, err := m.Subscription.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.WaitTimeout != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAnnotatedvalue(dAtA, i, uint64(m.WaitTimeout.Size()))
		n7, err := m.WaitTimeout.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NextResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NextResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AnnotatedValue != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAnnotatedvalue(dAtA, i, uint64(m.AnnotatedValue.Size()))
		n8, err := m.AnnotatedValue.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.NoAnnotatedValueYet {
		dAtA[i] = 0x10
		i++
		if m.NoAnnotatedValueYet {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AckRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AckRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Subscription != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAnnotatedvalue(dAtA, i, uint64(m.Subscription.Size()))
		n9, err := m.Subscription.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.AnnotatedValueID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAnnotatedvalue(dAtA, i, uint64(len(m.AnnotatedValueID)))
		i += copy(dAtA[i:], m.AnnotatedValueID)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AnnotatedValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnnotatedValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAnnotatedvalue(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if len(m.SourceTask) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAnnotatedvalue(dAtA, i, uint64(len(m.SourceTask)))
		i += copy(dAtA[i:], m.SourceTask)
	}
	if len(m.SourceTaskOutput) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAnnotatedvalue(dAtA, i, uint64(len(m.SourceTaskOutput)))
		i += copy(dAtA[i:], m.SourceTaskOutput)
	}
	if len(m.Link) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAnnotatedvalue(dAtA, i, uint64(len(m.Link)))
		i += copy(dAtA[i:], m.Link)
	}
	if len(m.SourceInputs) > 0 {
		for _, msg := range m.SourceInputs {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintAnnotatedvalue(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAnnotatedvalue(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.CreatedAt != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAnnotatedvalue(dAtA, i, uint64(m.CreatedAt.Size()))
		n10, err := m.CreatedAt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AnnotatedValueSourceInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnnotatedValueSourceInput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IDs) > 0 {
		for _, s := range m.IDs {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.InputName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAnnotatedvalue(dAtA, i, uint64(len(m.InputName)))
		i += copy(dAtA[i:], m.InputName)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetByIDRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetByIDRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAnnotatedvalue(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetByTaskAndDataRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetByTaskAndDataRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SourceTask) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAnnotatedvalue(dAtA, i, uint64(len(m.SourceTask)))
		i += copy(dAtA[i:], m.SourceTask)
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAnnotatedvalue(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IDs) > 0 {
		for _, s := range m.IDs {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.SourceTasks) > 0 {
		for _, s := range m.SourceTasks {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Data) > 0 {
		for _, s := range m.Data {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.CreatedAfter != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAnnotatedvalue(dAtA, i, uint64(m.CreatedAfter.Size()))
		n11, err := m.CreatedAfter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.CreatedBefore != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAnnotatedvalue(dAtA, i, uint64(m.CreatedBefore.Size()))
		n12, err := m.CreatedBefore.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.Limit != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAnnotatedvalue(dAtA, i, uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetOneResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetOneResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AnnotatedValue != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAnnotatedvalue(dAtA, i, uint64(m.AnnotatedValue.Size()))
		n13, err := m.AnnotatedValue.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AnnotatedValues) > 0 {
		for _, msg := range m.AnnotatedValues {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAnnotatedvalue(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintAnnotatedvalue(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CanPublishRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CanPublishResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Allowed {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PublishRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnnotatedValue != nil {
		l = m.AnnotatedValue.Size()
		n += 1 + l + sovAnnotatedvalue(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PublishResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubscribeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovAnnotatedvalue(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Subscription) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAnnotatedvalue(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubscribeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subscription != nil {
		l = m.Subscription.Size()
		n += 1 + l + sovAnnotatedvalue(uint64(l))
	}
	if m.TTL != nil {
		l = m.TTL.Size()
		n += 1 + l + sovAnnotatedvalue(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PingRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subscription != nil {
		l = m.Subscription.Size()
		n += 1 + l + sovAnnotatedvalue(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CloseRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subscription != nil {
		l = m.Subscription.Size()
		n += 1 + l + sovAnnotatedvalue(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NextRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subscription != nil {
		l = m.Subscription.Size()
		n += 1 + l + sovAnnotatedvalue(uint64(l))
	}
	if m.WaitTimeout != nil {
		l = m.WaitTimeout.Size()
		n += 1 + l + sovAnnotatedvalue(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NextResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnnotatedValue != nil {
		l = m.AnnotatedValue.Size()
		n += 1 + l + sovAnnotatedvalue(uint64(l))
	}
	if m.NoAnnotatedValueYet {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AckRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subscription != nil {
		l = m.Subscription.Size()
		n += 1 + l + sovAnnotatedvalue(uint64(l))
	}
	l = len(m.AnnotatedValueID)
	if l > 0 {
		n += 1 + l + sovAnnotatedvalue(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AnnotatedValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovAnnotatedvalue(uint64(l))
	}
	l = len(m.SourceTask)
	if l > 0 {
		n += 1 + l + sovAnnotatedvalue(uint64(l))
	}
	l = len(m.SourceTaskOutput)
	if l > 0 {
		n += 1 + l + sovAnnotatedvalue(uint64(l))
	}
	l = len(m.Link)
	if l > 0 {
		n += 1 + l + sovAnnotatedvalue(uint64(l))
	}
	if len(m.SourceInputs) > 0 {
		for _, e := range m.SourceInputs {
			l = e.Size()
			n += 1 + l + sovAnnotatedvalue(uint64(l))
		}
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovAnnotatedvalue(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovAnnotatedvalue(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AnnotatedValueSourceInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.IDs) > 0 {
		for _, s := range m.IDs {
			l = len(s)
			n += 1 + l + sovAnnotatedvalue(uint64(l))
		}
	}
	l = len(m.InputName)
	if l > 0 {
		n += 1 + l + sovAnnotatedvalue(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetByIDRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovAnnotatedvalue(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetByTaskAndDataRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SourceTask)
	if l > 0 {
		n += 1 + l + sovAnnotatedvalue(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovAnnotatedvalue(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.IDs) > 0 {
		for _, s := range m.IDs {
			l = len(s)
			n += 1 + l + sovAnnotatedvalue(uint64(l))
		}
	}
	if len(m.SourceTasks) > 0 {
		for _, s := range m.SourceTasks {
			l = len(s)
			n += 1 + l + sovAnnotatedvalue(uint64(l))
		}
	}
	if len(m.Data) > 0 {
		for _, s := range m.Data {
			l = len(s)
			n += 1 + l + sovAnnotatedvalue(uint64(l))
		}
	}
	if m.CreatedAfter != nil {
		l = m.CreatedAfter.Size()
		n += 1 + l + sovAnnotatedvalue(uint64(l))
	}
	if m.CreatedBefore != nil {
		l = m.CreatedBefore.Size()
		n += 1 + l + sovAnnotatedvalue(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovAnnotatedvalue(uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetOneResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnnotatedValue != nil {
		l = m.AnnotatedValue.Size()
		n += 1 + l + sovAnnotatedvalue(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AnnotatedValues) > 0 {
		for _, e := range m.AnnotatedValues {
			l = e.Size()
			n += 1 + l + sovAnnotatedvalue(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovAnnotatedvalue(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAnnotatedvalue(x uint64) (n int) {
	return sovAnnotatedvalue(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CanPublishRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotatedvalue
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CanPublishRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CanPublishRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotatedvalue(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CanPublishResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotatedvalue
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CanPublishResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CanPublishResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allowed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotatedvalue
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Allowed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotatedvalue(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublishRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotatedvalue
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublishRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublishRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnnotatedValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotatedvalue
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AnnotatedValue == nil {
				m.AnnotatedValue = &AnnotatedValue{}
			}
			if err := m.AnnotatedValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotatedvalue(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublishResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotatedvalue
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublishResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublishResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotatedvalue(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscribeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotatedvalue
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscribeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscribeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotatedvalue
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotatedvalue(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Subscription) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotatedvalue
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Subscription: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Subscription: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotatedvalue
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotatedvalue(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscribeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotatedvalue
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscribeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscribeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscription", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotatedvalue
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Subscription == nil {
				m.Subscription = &Subscription{}
			}
			if err := m.Subscription.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotatedvalue
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TTL == nil {
				m.TTL = &types.Duration{}
			}
			if err := m.TTL.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotatedvalue(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PingRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotatedvalue
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PingRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PingRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscription", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotatedvalue
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Subscription == nil {
				m.Subscription = &Subscription{}
			}
			if err := m.Subscription.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotatedvalue(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloseRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotatedvalue
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloseRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloseRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscription", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotatedvalue
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Subscription == nil {
				m.Subscription = &Subscription{}
			}
			if err := m.Subscription.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotatedvalue(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NextRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotatedvalue
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NextRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NextRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscription", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotatedvalue
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Subscription == nil {
				m.Subscription = &Subscription{}
			}
			if err := m.Subscription.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotatedvalue
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WaitTimeout == nil {
				m.WaitTimeout = &types.Duration{}
			}
			if err := m.WaitTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotatedvalue(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NextResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotatedvalue
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NextResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NextResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnnotatedValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotatedvalue
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AnnotatedValue == nil {
				m.AnnotatedValue = &AnnotatedValue{}
			}
			if err := m.AnnotatedValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoAnnotatedValueYet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotatedvalue
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoAnnotatedValueYet = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotatedvalue(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AckRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotatedvalue
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AckRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AckRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscription", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotatedvalue
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Subscription == nil {
				m.Subscription = &Subscription{}
			}
			if err := m.Subscription.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnnotatedValueID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotatedvalue
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnnotatedValueID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotatedvalue(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnnotatedValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotatedvalue
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnnotatedValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnnotatedValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotatedvalue
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceTask", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotatedvalue
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceTask = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceTaskOutput", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotatedvalue
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceTaskOutput = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotatedvalue
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Link = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceInputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotatedvalue
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceInputs = append(m.SourceInputs, &AnnotatedValueSourceInput{})
			if err := m.SourceInputs[len(m.SourceInputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotatedvalue
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotatedvalue
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotatedvalue(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnnotatedValueSourceInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotatedvalue
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnnotatedValueSourceInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnnotatedValueSourceInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotatedvalue
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IDs = append(m.IDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotatedvalue
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotatedvalue(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetByIDRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotatedvalue
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetByIDRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetByIDRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotatedvalue
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotatedvalue(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetByTaskAndDataRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotatedvalue
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetByTaskAndDataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetByTaskAndDataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceTask", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotatedvalue
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceTask = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotatedvalue
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotatedvalue(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotatedvalue
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotatedvalue
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IDs = append(m.IDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceTasks", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotatedvalue
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceTasks = append(m.SourceTasks, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotatedvalue
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAfter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotatedvalue
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAfter == nil {
				m.CreatedAfter = &types.Timestamp{}
			}
			if err := m.CreatedAfter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedBefore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotatedvalue
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedBefore == nil {
				m.CreatedBefore = &types.Timestamp{}
			}
			if err := m.CreatedBefore.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotatedvalue
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotatedvalue(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetOneResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotatedvalue
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetOneResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetOneResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnnotatedValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotatedvalue
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AnnotatedValue == nil {
				m.AnnotatedValue = &AnnotatedValue{}
			}
			if err := m.AnnotatedValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotatedvalue(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotatedvalue
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnnotatedValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotatedvalue
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnnotatedValues = append(m.AnnotatedValues, &AnnotatedValue{})
			if err := m.AnnotatedValues[len(m.AnnotatedValues)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotatedvalue(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotatedvalue
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAnnotatedvalue(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAnnotatedvalue
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAnnotatedvalue
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAnnotatedvalue
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAnnotatedvalue
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAnnotatedvalue
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAnnotatedvalue(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAnnotatedvalue = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAnnotatedvalue   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("annotatedvalue.proto", fileDescriptor_annotatedvalue_32e9cdee10a37494)
}

var fileDescriptor_annotatedvalue_32e9cdee10a37494 = []byte{
	// 1100 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xcd, 0x6e, 0x22, 0xc7,
	0x13, 0xff, 0xc3, 0xd8, 0xc6, 0x14, 0x98, 0xc5, 0x6d, 0xcb, 0x8b, 0x67, 0x2d, 0x60, 0xe7, 0xf2,
	0x77, 0x3e, 0x16, 0x22, 0xaf, 0x14, 0x69, 0x65, 0x65, 0x65, 0x30, 0x89, 0x4d, 0xe4, 0xd8, 0x56,
	0x1b, 0x65, 0xf3, 0x71, 0x70, 0x9a, 0xa1, 0xcd, 0xce, 0x32, 0xcc, 0x4c, 0xa6, 0x7b, 0xb2, 0x71,
	0x8e, 0x91, 0x22, 0xe5, 0x90, 0x07, 0xc8, 0xb3, 0xe4, 0x98, 0x53, 0x8e, 0x79, 0x02, 0x14, 0x4d,
	0xae, 0x79, 0x88, 0x68, 0x7a, 0x1a, 0x66, 0x86, 0x31, 0xe6, 0x10, 0x5f, 0x50, 0x77, 0x55, 0xfd,
	0x7e, 0x55, 0x5d, 0x55, 0x53, 0x05, 0x6c, 0x13, 0xcb, 0xb2, 0x39, 0xe1, 0x74, 0xf0, 0x1d, 0x31,
	0x3d, 0xda, 0x70, 0x5c, 0x9b, 0xdb, 0xa8, 0x94, 0x94, 0xaa, 0x2f, 0x86, 0x06, 0x7f, 0xed, 0xf5,
	0x1b, 0xba, 0x3d, 0x6e, 0x0e, 0x6d, 0x93, 0x58, 0xc3, 0xa6, 0x30, 0xec, 0x7b, 0x37, 0x4d, 0x87,
	0xdf, 0x3a, 0x94, 0x35, 0x07, 0x9e, 0x4b, 0xb8, 0x61, 0x5b, 0xb3, 0x43, 0x48, 0xa5, 0x3e, 0x5f,
	0x0e, 0xa5, 0x63, 0x87, 0xdf, 0x86, 0xbf, 0x12, 0x74, 0xb8, 0x1c, 0xc4, 0x8d, 0x31, 0x65, 0x9c,
	0x8c, 0x9d, 0xe8, 0x24, 0xc1, 0xcf, 0x12, 0xe0, 0xa1, 0x1d, 0x41, 0x83, 0x9b, 0xb8, 0x88, 0x53,
	0x68, 0xae, 0x6d, 0xc1, 0xe6, 0x31, 0xb1, 0x2e, 0xbd, 0xbe, 0x69, 0xb0, 0xd7, 0x98, 0x7e, 0xeb,
	0x51, 0xc6, 0xb5, 0x06, 0xa0, 0xb8, 0x90, 0x39, 0xb6, 0xc5, 0x28, 0xaa, 0x40, 0xae, 0x65, 0x9a,
	0xf6, 0x5b, 0x3a, 0xa8, 0x64, 0xea, 0x99, 0xfd, 0x75, 0x9c, 0x23, 0xe1, 0x55, 0xfb, 0x02, 0x4a,
	0x49, 0x06, 0xf4, 0x09, 0x94, 0x5a, 0xd3, 0x24, 0x7e, 0x1e, 0x24, 0x51, 0x40, 0x0a, 0x07, 0xd5,
	0xc6, 0x5c, 0xc6, 0x93, 0x56, 0x38, 0x4a, 0xbd, 0xb8, 0x6b, 0x9b, 0xf0, 0x68, 0x2e, 0x0c, 0xad,
	0x01, 0xe5, 0x2b, 0xaf, 0xcf, 0x74, 0xd7, 0xe8, 0xd3, 0xa9, 0x3b, 0x15, 0xd6, 0x8f, 0x4d, 0x83,
	0x5a, 0xbc, 0xdb, 0x11, 0x8e, 0xf2, 0x78, 0x5d, 0x97, 0x77, 0xad, 0x0a, 0x45, 0x69, 0xef, 0x04,
	0x85, 0x41, 0x25, 0xc8, 0x4a, 0x2b, 0x05, 0x67, 0x8d, 0x8e, 0xf6, 0x63, 0x06, 0x36, 0x63, 0x84,
	0xf2, 0xb1, 0x47, 0x49, 0x94, 0x0c, 0x7f, 0x6f, 0x3e, 0xfc, 0xb8, 0x0d, 0x2e, 0xb2, 0xb8, 0x9f,
	0xf7, 0x40, 0xe9, 0xf5, 0xce, 0x2a, 0x59, 0x01, 0xdc, 0x6d, 0x0c, 0x6d, 0x7b, 0x68, 0xca, 0x0e,
	0xeb, 0x7b, 0x37, 0x8d, 0x8e, 0x6c, 0x14, 0xac, 0xf0, 0xde, 0x99, 0x76, 0x01, 0x85, 0x4b, 0xc3,
	0x1a, 0x4e, 0xdf, 0xf3, 0x9f, 0xbd, 0x6b, 0x97, 0x50, 0x3c, 0x36, 0x6d, 0x46, 0x1f, 0x8e, 0xf1,
	0x97, 0x0c, 0x14, 0xce, 0xe9, 0xf7, 0xfc, 0xc1, 0x18, 0xd1, 0x21, 0x14, 0x5e, 0x11, 0x83, 0xf7,
	0x8c, 0x31, 0xb5, 0x3d, 0xbe, 0x3c, 0x53, 0x85, 0xb7, 0x91, 0xb5, 0xf6, 0x73, 0x06, 0x8a, 0x61,
	0x38, 0xb2, 0x62, 0x0f, 0xd4, 0x72, 0xe8, 0x03, 0xd8, 0x3a, 0xb7, 0x93, 0x36, 0x5f, 0xd2, 0x30,
	0xba, 0x75, 0xbc, 0x65, 0xa5, 0x55, 0xda, 0x0f, 0x00, 0x2d, 0x7d, 0xf4, 0x70, 0x79, 0x79, 0x17,
	0xca, 0x49, 0x27, 0xdd, 0x8e, 0x70, 0x9f, 0xc7, 0x65, 0x32, 0x27, 0xd7, 0x7e, 0x52, 0xe6, 0x9f,
	0x8d, 0x76, 0x20, 0x6b, 0x84, 0x9f, 0x68, 0xbe, 0xbd, 0xe6, 0x4f, 0x6a, 0xd9, 0x6e, 0x07, 0x67,
	0x8d, 0x01, 0x6a, 0x42, 0x81, 0xd9, 0x9e, 0xab, 0xd3, 0x6b, 0x4e, 0xd8, 0x28, 0x64, 0x6c, 0x97,
	0xfc, 0x49, 0x0d, 0xae, 0x84, 0xb8, 0x47, 0xd8, 0x08, 0x03, 0x9b, 0x9d, 0x51, 0x1b, 0x50, 0x0c,
	0x70, 0x6d, 0x7b, 0xdc, 0xf1, 0x78, 0x45, 0x11, 0xb8, 0x6d, 0x7f, 0x52, 0x2b, 0x47, 0xb8, 0x0b,
	0xa1, 0xc3, 0x65, 0x36, 0x27, 0x41, 0x7b, 0xb0, 0x62, 0x1a, 0xd6, 0xa8, 0xb2, 0x22, 0x50, 0xeb,
	0xfe, 0xa4, 0xb6, 0x72, 0x66, 0x58, 0x23, 0x2c, 0xa4, 0xe8, 0x1b, 0xd8, 0x90, 0x1e, 0x0c, 0xcb,
	0xf1, 0x38, 0xab, 0xac, 0xd6, 0x95, 0xfd, 0xc2, 0xc1, 0x3b, 0xf7, 0x97, 0x2c, 0x74, 0xdb, 0x0d,
	0x10, 0xed, 0xb2, 0x3f, 0xa9, 0x15, 0x63, 0x02, 0x86, 0x8b, 0x2c, 0x76, 0x0b, 0xfc, 0x0f, 0x08,
	0x27, 0x95, 0xb5, 0xc8, 0x7f, 0x87, 0x70, 0x82, 0x85, 0x14, 0x9d, 0x02, 0xe8, 0x2e, 0x0d, 0x88,
	0xaf, 0x09, 0xaf, 0xe4, 0x44, 0xa5, 0xd4, 0x54, 0x03, 0xf6, 0xa6, 0x23, 0xb6, 0xbd, 0xe1, 0x4f,
	0x6a, 0xf9, 0xe3, 0x10, 0xd1, 0xe2, 0x38, 0xaf, 0x4f, 0x8f, 0xda, 0x00, 0x76, 0x17, 0x06, 0x89,
	0x76, 0x41, 0x31, 0x06, 0xac, 0x92, 0xa9, 0x2b, 0xfb, 0xf9, 0x76, 0xce, 0x9f, 0xd4, 0x94, 0x6e,
	0x87, 0xe1, 0x40, 0x86, 0xde, 0x07, 0x10, 0x4f, 0xbf, 0xb6, 0xc8, 0x98, 0xca, 0x9a, 0x08, 0x2f,
	0x02, 0x79, 0x4e, 0xc6, 0x14, 0xe7, 0x8d, 0xe9, 0x51, 0xab, 0x43, 0xe9, 0x84, 0xf2, 0xf6, 0x6d,
	0xb7, 0x33, 0xed, 0xb6, 0x68, 0x9a, 0xe5, 0xc5, 0x34, 0xfb, 0x0c, 0x1e, 0x0b, 0x8b, 0xa0, 0x04,
	0x2d, 0x6b, 0x20, 0xde, 0x2a, 0x4d, 0xab, 0x10, 0x2b, 0xb4, 0x84, 0xc4, 0xcb, 0x8d, 0x40, 0xa4,
	0x46, 0xb6, 0x9a, 0x48, 0x90, 0xf6, 0x4f, 0x06, 0xe0, 0x84, 0xce, 0xbe, 0xf9, 0x32, 0x04, 0x91,
	0x87, 0x0f, 0xc1, 0x8a, 0xd1, 0x61, 0xa8, 0x0e, 0x85, 0x88, 0x94, 0x55, 0xb2, 0x42, 0x53, 0x88,
	0x58, 0xd9, 0x8c, 0x56, 0x11, 0xaa, 0x30, 0xef, 0x2f, 0xa1, 0x38, 0xcd, 0xe2, 0x0d, 0xa7, 0xae,
	0xe8, 0x8e, 0x7b, 0x33, 0x8f, 0x8b, 0x7a, 0xcc, 0x1e, 0x1d, 0xc1, 0x86, 0xc4, 0xb7, 0xe9, 0x8d,
	0xed, 0xd2, 0xca, 0xea, 0x52, 0x82, 0x0d, 0x3d, 0x0e, 0x40, 0xdb, 0xb0, 0x7a, 0x66, 0x8c, 0x0d,
	0x2e, 0x1a, 0x43, 0xc1, 0xab, 0x66, 0x70, 0x09, 0x16, 0xd9, 0x09, 0xe5, 0x17, 0x16, 0x7d, 0xe8,
	0xa9, 0xa2, 0xbd, 0x82, 0x82, 0xc8, 0xa3, 0xa4, 0x3d, 0x85, 0x47, 0x49, 0x40, 0x98, 0xd4, 0xe5,
	0xbc, 0x8f, 0x92, 0xbc, 0xec, 0xe0, 0xb7, 0x0c, 0x3c, 0x4e, 0xda, 0xc8, 0x85, 0x49, 0x5d, 0x74,
	0x05, 0x10, 0xed, 0x71, 0xf4, 0x74, 0x9e, 0x3a, 0xb5, 0xf8, 0x55, 0xed, 0x3e, 0x13, 0x19, 0xfa,
	0xa7, 0x90, 0x9b, 0x32, 0xa6, 0x82, 0x9d, 0xa3, 0xab, 0x2d, 0xd4, 0x87, 0x5c, 0x07, 0x7e, 0x16,
	0xb6, 0xef, 0xfa, 0x6c, 0xd0, 0x25, 0xe4, 0x67, 0x3b, 0x19, 0xd5, 0x17, 0xcc, 0xce, 0xd9, 0xfe,
	0x57, 0x9f, 0xde, 0x63, 0x21, 0xc3, 0x3e, 0x84, 0x95, 0x60, 0xc3, 0xa2, 0x27, 0xa9, 0x98, 0xa2,
	0xbd, 0xab, 0xee, 0xa4, 0x1a, 0xe8, 0xe3, 0xe0, 0x7f, 0x19, 0xfa, 0x08, 0x56, 0xc5, 0x36, 0x45,
	0xa9, 0x31, 0x1e, 0x5f, 0xb2, 0x0b, 0xe1, 0x2d, 0x58, 0x09, 0x56, 0x55, 0xda, 0x77, 0x6c, 0x9f,
	0xaa, 0x7b, 0x77, 0x2b, 0x65, 0xf8, 0x2f, 0x40, 0x69, 0xe9, 0x23, 0xa4, 0xa6, 0xda, 0x63, 0xb6,
	0x78, 0x16, 0x79, 0x3f, 0xf8, 0x3d, 0x0b, 0x3b, 0x73, 0x5d, 0x44, 0x87, 0x06, 0xe3, 0xee, 0x2d,
	0x3a, 0x82, 0x35, 0x4c, 0x75, 0xdb, 0x1d, 0xa0, 0x25, 0x7d, 0xb7, 0xf0, 0x69, 0x5d, 0xc8, 0xc9,
	0x89, 0x94, 0xa6, 0x48, 0x8e, 0x2a, 0xf5, 0x2e, 0x7d, 0xfc, 0x53, 0xfb, 0x1a, 0xca, 0xf3, 0xa3,
	0x0b, 0xfd, 0xff, 0x4e, 0xce, 0xf4, 0x70, 0x5b, 0x4a, 0xfe, 0x12, 0x94, 0x13, 0xca, 0xd3, 0xf9,
	0x8b, 0x86, 0x9b, 0xfa, 0xe4, 0x4e, 0x5d, 0x88, 0x6f, 0x9f, 0xfe, 0xe1, 0x57, 0x33, 0x7f, 0xfa,
	0xd5, 0xcc, 0x5f, 0x7e, 0x35, 0xf3, 0xeb, 0xdf, 0xd5, 0xff, 0x7d, 0xf5, 0x61, 0xec, 0x8f, 0x76,
	0xcb, 0x7c, 0x43, 0xfa, 0x6e, 0xf7, 0xa2, 0x39, 0xb2, 0x89, 0xf9, 0x86, 0x3c, 0xb3, 0x1d, 0xea,
	0x12, 0x6e, 0xbb, 0x4d, 0x67, 0x34, 0x6c, 0x26, 0x59, 0xfb, 0x6b, 0x22, 0x83, 0xcf, 0xff, 0x0d,
	0x00, 0x00, 0xff, 0xff, 0x5a, 0x02, 0x92, 0xfe, 0x7c, 0x0c, 0x00, 0x00,
}
