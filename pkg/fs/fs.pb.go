// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: fs.proto

package fs // import "github.com/AljabrIO/koalja-operator/pkg/fs"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import v1 "k8s.io/apimachinery/pkg/apis/meta/v1"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// CreateVolumeForWriteRequest contains arguments for CreateVolumeForWrite.
type CreateVolumeForWriteRequest struct {
	// Estimated capacity (in bytes) of the data that will be written
	EstimatedCapacity int64 `protobuf:"varint,1,opt,name=EstimatedCapacity,proto3" json:"EstimatedCapacity,omitempty"`
	// Name of the Node on which the PV must reside.
	// If not set, a random node is picked.
	NodeName string `protobuf:"bytes,2,opt,name=NodeName,proto3" json:"NodeName,omitempty"`
	// If set and allow, this the PersistentVolume will be owned by this owner reference.
	Owner *v1.OwnerReference `protobuf:"bytes,3,opt,name=Owner" json:"Owner,omitempty"`
	// Namespace of the resources created for this request.
	Namespace            string   `protobuf:"bytes,4,opt,name=Namespace,proto3" json:"Namespace,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateVolumeForWriteRequest) Reset()         { *m = CreateVolumeForWriteRequest{} }
func (m *CreateVolumeForWriteRequest) String() string { return proto.CompactTextString(m) }
func (*CreateVolumeForWriteRequest) ProtoMessage()    {}
func (*CreateVolumeForWriteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fs_c1d0750a3158d925, []int{0}
}
func (m *CreateVolumeForWriteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateVolumeForWriteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateVolumeForWriteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CreateVolumeForWriteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateVolumeForWriteRequest.Merge(dst, src)
}
func (m *CreateVolumeForWriteRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateVolumeForWriteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateVolumeForWriteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateVolumeForWriteRequest proto.InternalMessageInfo

func (m *CreateVolumeForWriteRequest) GetEstimatedCapacity() int64 {
	if m != nil {
		return m.EstimatedCapacity
	}
	return 0
}

func (m *CreateVolumeForWriteRequest) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *CreateVolumeForWriteRequest) GetOwner() *v1.OwnerReference {
	if m != nil {
		return m.Owner
	}
	return nil
}

func (m *CreateVolumeForWriteRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// CreateVolumeForWriteResponse contains results for CreateVolumeForWrite.
type CreateVolumeForWriteResponse struct {
	// Name of the created PersistentVolume
	VolumeName string `protobuf:"bytes,1,opt,name=VolumeName,proto3" json:"VolumeName,omitempty"`
	// Name of the PersistentVolumeClaim to mount
	VolumeClaimName string `protobuf:"bytes,2,opt,name=VolumeClaimName,proto3" json:"VolumeClaimName,omitempty"`
	// Path of Node that contains the Volume (as HostPath volume)
	// Either VolumeName or VolumePath must be set, not both.
	VolumePath string `protobuf:"bytes,3,opt,name=VolumePath,proto3" json:"VolumePath,omitempty"`
	// SubPath to add to VolumeName, VolumeClaimName or VolumePath.
	SubPath string `protobuf:"bytes,4,opt,name=SubPath,proto3" json:"SubPath,omitempty"`
	// Name of the Node on which the volume is created
	NodeName string `protobuf:"bytes,5,opt,name=NodeName,proto3" json:"NodeName,omitempty"`
	// If set, the caller must delete the PersistentVolume or PersistentVolumeClaim after use
	DeleteAfterUse       bool     `protobuf:"varint,6,opt,name=DeleteAfterUse,proto3" json:"DeleteAfterUse,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateVolumeForWriteResponse) Reset()         { *m = CreateVolumeForWriteResponse{} }
func (m *CreateVolumeForWriteResponse) String() string { return proto.CompactTextString(m) }
func (*CreateVolumeForWriteResponse) ProtoMessage()    {}
func (*CreateVolumeForWriteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fs_c1d0750a3158d925, []int{1}
}
func (m *CreateVolumeForWriteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateVolumeForWriteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateVolumeForWriteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CreateVolumeForWriteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateVolumeForWriteResponse.Merge(dst, src)
}
func (m *CreateVolumeForWriteResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateVolumeForWriteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateVolumeForWriteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateVolumeForWriteResponse proto.InternalMessageInfo

func (m *CreateVolumeForWriteResponse) GetVolumeName() string {
	if m != nil {
		return m.VolumeName
	}
	return ""
}

func (m *CreateVolumeForWriteResponse) GetVolumeClaimName() string {
	if m != nil {
		return m.VolumeClaimName
	}
	return ""
}

func (m *CreateVolumeForWriteResponse) GetVolumePath() string {
	if m != nil {
		return m.VolumePath
	}
	return ""
}

func (m *CreateVolumeForWriteResponse) GetSubPath() string {
	if m != nil {
		return m.SubPath
	}
	return ""
}

func (m *CreateVolumeForWriteResponse) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *CreateVolumeForWriteResponse) GetDeleteAfterUse() bool {
	if m != nil {
		return m.DeleteAfterUse
	}
	return false
}

// CreateFileURIRequest contains arguments for CreateFileURI
type CreateFileURIRequest struct {
	// Scheme of the generated URI
	Scheme string `protobuf:"bytes,1,opt,name=Scheme,proto3" json:"Scheme,omitempty"`
	// Name of the PersistentVolume that contains the file/dir
	VolumeName string `protobuf:"bytes,2,opt,name=VolumeName,proto3" json:"VolumeName,omitempty"`
	// Name of the PersistentVolumeClaim that contains the file/dir
	VolumeClaimName string `protobuf:"bytes,3,opt,name=VolumeClaimName,proto3" json:"VolumeClaimName,omitempty"`
	// Path of Node that contains the Volume (as HostPath volume)
	// One of VolumeName, VolumeClaimName or VolumePath must be set, not multiple.
	VolumePath string `protobuf:"bytes,4,opt,name=VolumePath,proto3" json:"VolumePath,omitempty"`
	// SubPath to add to VolumeName or VolumePath.
	SubPath string `protobuf:"bytes,5,opt,name=SubPath,proto3" json:"SubPath,omitempty"`
	// Name of the Node on which the volume resides
	NodeName string `protobuf:"bytes,6,opt,name=NodeName,proto3" json:"NodeName,omitempty"`
	// Local path of the file/dir in the Volume
	LocalPath string `protobuf:"bytes,7,opt,name=LocalPath,proto3" json:"LocalPath,omitempty"`
	// IsDir indicates if the URI is for a file (false) or a directory (true)
	IsDir                bool     `protobuf:"varint,8,opt,name=IsDir,proto3" json:"IsDir,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateFileURIRequest) Reset()         { *m = CreateFileURIRequest{} }
func (m *CreateFileURIRequest) String() string { return proto.CompactTextString(m) }
func (*CreateFileURIRequest) ProtoMessage()    {}
func (*CreateFileURIRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fs_c1d0750a3158d925, []int{2}
}
func (m *CreateFileURIRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateFileURIRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateFileURIRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CreateFileURIRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateFileURIRequest.Merge(dst, src)
}
func (m *CreateFileURIRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateFileURIRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateFileURIRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateFileURIRequest proto.InternalMessageInfo

func (m *CreateFileURIRequest) GetScheme() string {
	if m != nil {
		return m.Scheme
	}
	return ""
}

func (m *CreateFileURIRequest) GetVolumeName() string {
	if m != nil {
		return m.VolumeName
	}
	return ""
}

func (m *CreateFileURIRequest) GetVolumeClaimName() string {
	if m != nil {
		return m.VolumeClaimName
	}
	return ""
}

func (m *CreateFileURIRequest) GetVolumePath() string {
	if m != nil {
		return m.VolumePath
	}
	return ""
}

func (m *CreateFileURIRequest) GetSubPath() string {
	if m != nil {
		return m.SubPath
	}
	return ""
}

func (m *CreateFileURIRequest) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *CreateFileURIRequest) GetLocalPath() string {
	if m != nil {
		return m.LocalPath
	}
	return ""
}

func (m *CreateFileURIRequest) GetIsDir() bool {
	if m != nil {
		return m.IsDir
	}
	return false
}

// CreateFileURIRequest contains results for CreateFileURI
type CreateFileURIResponse struct {
	// The created URI
	URI                  string   `protobuf:"bytes,1,opt,name=URI,proto3" json:"URI,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateFileURIResponse) Reset()         { *m = CreateFileURIResponse{} }
func (m *CreateFileURIResponse) String() string { return proto.CompactTextString(m) }
func (*CreateFileURIResponse) ProtoMessage()    {}
func (*CreateFileURIResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fs_c1d0750a3158d925, []int{3}
}
func (m *CreateFileURIResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateFileURIResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateFileURIResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CreateFileURIResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateFileURIResponse.Merge(dst, src)
}
func (m *CreateFileURIResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateFileURIResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateFileURIResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateFileURIResponse proto.InternalMessageInfo

func (m *CreateFileURIResponse) GetURI() string {
	if m != nil {
		return m.URI
	}
	return ""
}

// CreateVolumeForReadRequest contains arguments for CreateVolumeForRead
type CreateVolumeForReadRequest struct {
	// The URI to read
	URI string `protobuf:"bytes,1,opt,name=URI,proto3" json:"URI,omitempty"`
	// If set and allow, this the PersistentVolume will be owned by this owner reference.
	Owner *v1.OwnerReference `protobuf:"bytes,2,opt,name=Owner" json:"Owner,omitempty"`
	// Namespace of the resources created for this request.
	Namespace            string   `protobuf:"bytes,3,opt,name=Namespace,proto3" json:"Namespace,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateVolumeForReadRequest) Reset()         { *m = CreateVolumeForReadRequest{} }
func (m *CreateVolumeForReadRequest) String() string { return proto.CompactTextString(m) }
func (*CreateVolumeForReadRequest) ProtoMessage()    {}
func (*CreateVolumeForReadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fs_c1d0750a3158d925, []int{4}
}
func (m *CreateVolumeForReadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateVolumeForReadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateVolumeForReadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CreateVolumeForReadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateVolumeForReadRequest.Merge(dst, src)
}
func (m *CreateVolumeForReadRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateVolumeForReadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateVolumeForReadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateVolumeForReadRequest proto.InternalMessageInfo

func (m *CreateVolumeForReadRequest) GetURI() string {
	if m != nil {
		return m.URI
	}
	return ""
}

func (m *CreateVolumeForReadRequest) GetOwner() *v1.OwnerReference {
	if m != nil {
		return m.Owner
	}
	return nil
}

func (m *CreateVolumeForReadRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// CreateVolumeForReadResponse contains results for CreateVolumeForRead
type CreateVolumeForReadResponse struct {
	// Name of the created PersistentVolume
	VolumeName string `protobuf:"bytes,1,opt,name=VolumeName,proto3" json:"VolumeName,omitempty"`
	// Name of the PersistentVolumeClaim to mount
	VolumeClaimName string `protobuf:"bytes,2,opt,name=VolumeClaimName,proto3" json:"VolumeClaimName,omitempty"`
	// Path of Node that contains the Volume (as HostPath volume)
	// One of VolumeName, VolumeClaimName or VolumePath must be set, not multiple.
	VolumePath string `protobuf:"bytes,3,opt,name=VolumePath,proto3" json:"VolumePath,omitempty"`
	// SubPath to add to VolumeName or VolumePath.
	SubPath string `protobuf:"bytes,4,opt,name=SubPath,proto3" json:"SubPath,omitempty"`
	// Name of the Node on which the volume is resides
	NodeName string `protobuf:"bytes,5,opt,name=NodeName,proto3" json:"NodeName,omitempty"`
	// Local path of the file/dir in the PersistentVolume
	LocalPath string `protobuf:"bytes,6,opt,name=LocalPath,proto3" json:"LocalPath,omitempty"`
	// IsDir indicates if the URI is for a file (false) or a directory (true)
	IsDir bool `protobuf:"varint,7,opt,name=IsDir,proto3" json:"IsDir,omitempty"`
	// If set, the caller must delete the PersistentVolume after use
	DeleteAfterUse       bool     `protobuf:"varint,8,opt,name=DeleteAfterUse,proto3" json:"DeleteAfterUse,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateVolumeForReadResponse) Reset()         { *m = CreateVolumeForReadResponse{} }
func (m *CreateVolumeForReadResponse) String() string { return proto.CompactTextString(m) }
func (*CreateVolumeForReadResponse) ProtoMessage()    {}
func (*CreateVolumeForReadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fs_c1d0750a3158d925, []int{5}
}
func (m *CreateVolumeForReadResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateVolumeForReadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateVolumeForReadResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CreateVolumeForReadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateVolumeForReadResponse.Merge(dst, src)
}
func (m *CreateVolumeForReadResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateVolumeForReadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateVolumeForReadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateVolumeForReadResponse proto.InternalMessageInfo

func (m *CreateVolumeForReadResponse) GetVolumeName() string {
	if m != nil {
		return m.VolumeName
	}
	return ""
}

func (m *CreateVolumeForReadResponse) GetVolumeClaimName() string {
	if m != nil {
		return m.VolumeClaimName
	}
	return ""
}

func (m *CreateVolumeForReadResponse) GetVolumePath() string {
	if m != nil {
		return m.VolumePath
	}
	return ""
}

func (m *CreateVolumeForReadResponse) GetSubPath() string {
	if m != nil {
		return m.SubPath
	}
	return ""
}

func (m *CreateVolumeForReadResponse) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *CreateVolumeForReadResponse) GetLocalPath() string {
	if m != nil {
		return m.LocalPath
	}
	return ""
}

func (m *CreateVolumeForReadResponse) GetIsDir() bool {
	if m != nil {
		return m.IsDir
	}
	return false
}

func (m *CreateVolumeForReadResponse) GetDeleteAfterUse() bool {
	if m != nil {
		return m.DeleteAfterUse
	}
	return false
}

type CreateFileViewRequest struct {
	// The URI of the file to create a view for
	URI string `protobuf:"bytes,1,opt,name=URI,proto3" json:"URI,omitempty"`
	// If set, a small preview is returned instead of the full content
	Preview              bool     `protobuf:"varint,2,opt,name=Preview,proto3" json:"Preview,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateFileViewRequest) Reset()         { *m = CreateFileViewRequest{} }
func (m *CreateFileViewRequest) String() string { return proto.CompactTextString(m) }
func (*CreateFileViewRequest) ProtoMessage()    {}
func (*CreateFileViewRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fs_c1d0750a3158d925, []int{6}
}
func (m *CreateFileViewRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateFileViewRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateFileViewRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CreateFileViewRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateFileViewRequest.Merge(dst, src)
}
func (m *CreateFileViewRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateFileViewRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateFileViewRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateFileViewRequest proto.InternalMessageInfo

func (m *CreateFileViewRequest) GetURI() string {
	if m != nil {
		return m.URI
	}
	return ""
}

func (m *CreateFileViewRequest) GetPreview() bool {
	if m != nil {
		return m.Preview
	}
	return false
}

type CreateFileViewResponse struct {
	// The content of the view
	Content []byte `protobuf:"bytes,1,opt,name=Content,proto3" json:"Content,omitempty"`
	// The type of content of the view
	ContentType          string   `protobuf:"bytes,2,opt,name=ContentType,proto3" json:"ContentType,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateFileViewResponse) Reset()         { *m = CreateFileViewResponse{} }
func (m *CreateFileViewResponse) String() string { return proto.CompactTextString(m) }
func (*CreateFileViewResponse) ProtoMessage()    {}
func (*CreateFileViewResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fs_c1d0750a3158d925, []int{7}
}
func (m *CreateFileViewResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateFileViewResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateFileViewResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CreateFileViewResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateFileViewResponse.Merge(dst, src)
}
func (m *CreateFileViewResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateFileViewResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateFileViewResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateFileViewResponse proto.InternalMessageInfo

func (m *CreateFileViewResponse) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *CreateFileViewResponse) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

func init() {
	proto.RegisterType((*CreateVolumeForWriteRequest)(nil), "fs.CreateVolumeForWriteRequest")
	proto.RegisterType((*CreateVolumeForWriteResponse)(nil), "fs.CreateVolumeForWriteResponse")
	proto.RegisterType((*CreateFileURIRequest)(nil), "fs.CreateFileURIRequest")
	proto.RegisterType((*CreateFileURIResponse)(nil), "fs.CreateFileURIResponse")
	proto.RegisterType((*CreateVolumeForReadRequest)(nil), "fs.CreateVolumeForReadRequest")
	proto.RegisterType((*CreateVolumeForReadResponse)(nil), "fs.CreateVolumeForReadResponse")
	proto.RegisterType((*CreateFileViewRequest)(nil), "fs.CreateFileViewRequest")
	proto.RegisterType((*CreateFileViewResponse)(nil), "fs.CreateFileViewResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// FileSystemClient is the client API for FileSystem service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FileSystemClient interface {
	// CreateVolumeForWrite creates a PersistentVolume that can be used to
	// write files to.
	CreateVolumeForWrite(ctx context.Context, in *CreateVolumeForWriteRequest, opts ...grpc.CallOption) (*CreateVolumeForWriteResponse, error)
	// CreateFileURI creates a URI for the given file/dir
	CreateFileURI(ctx context.Context, in *CreateFileURIRequest, opts ...grpc.CallOption) (*CreateFileURIResponse, error)
	// CreateVolumeForRead creates a PersistentVolume for reading a given URI
	CreateVolumeForRead(ctx context.Context, in *CreateVolumeForReadRequest, opts ...grpc.CallOption) (*CreateVolumeForReadResponse, error)
	// CreateFileView returns a view on the given file identified by the given URI.
	CreateFileView(ctx context.Context, in *CreateFileViewRequest, opts ...grpc.CallOption) (*CreateFileViewResponse, error)
}

type fileSystemClient struct {
	cc *grpc.ClientConn
}

func NewFileSystemClient(cc *grpc.ClientConn) FileSystemClient {
	return &fileSystemClient{cc}
}

func (c *fileSystemClient) CreateVolumeForWrite(ctx context.Context, in *CreateVolumeForWriteRequest, opts ...grpc.CallOption) (*CreateVolumeForWriteResponse, error) {
	out := new(CreateVolumeForWriteResponse)
	err := c.cc.Invoke(ctx, "/fs.FileSystem/CreateVolumeForWrite", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileSystemClient) CreateFileURI(ctx context.Context, in *CreateFileURIRequest, opts ...grpc.CallOption) (*CreateFileURIResponse, error) {
	out := new(CreateFileURIResponse)
	err := c.cc.Invoke(ctx, "/fs.FileSystem/CreateFileURI", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileSystemClient) CreateVolumeForRead(ctx context.Context, in *CreateVolumeForReadRequest, opts ...grpc.CallOption) (*CreateVolumeForReadResponse, error) {
	out := new(CreateVolumeForReadResponse)
	err := c.cc.Invoke(ctx, "/fs.FileSystem/CreateVolumeForRead", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileSystemClient) CreateFileView(ctx context.Context, in *CreateFileViewRequest, opts ...grpc.CallOption) (*CreateFileViewResponse, error) {
	out := new(CreateFileViewResponse)
	err := c.cc.Invoke(ctx, "/fs.FileSystem/CreateFileView", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FileSystemServer is the server API for FileSystem service.
type FileSystemServer interface {
	// CreateVolumeForWrite creates a PersistentVolume that can be used to
	// write files to.
	CreateVolumeForWrite(context.Context, *CreateVolumeForWriteRequest) (*CreateVolumeForWriteResponse, error)
	// CreateFileURI creates a URI for the given file/dir
	CreateFileURI(context.Context, *CreateFileURIRequest) (*CreateFileURIResponse, error)
	// CreateVolumeForRead creates a PersistentVolume for reading a given URI
	CreateVolumeForRead(context.Context, *CreateVolumeForReadRequest) (*CreateVolumeForReadResponse, error)
	// CreateFileView returns a view on the given file identified by the given URI.
	CreateFileView(context.Context, *CreateFileViewRequest) (*CreateFileViewResponse, error)
}

func RegisterFileSystemServer(s *grpc.Server, srv FileSystemServer) {
	s.RegisterService(&_FileSystem_serviceDesc, srv)
}

func _FileSystem_CreateVolumeForWrite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVolumeForWriteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileSystemServer).CreateVolumeForWrite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fs.FileSystem/CreateVolumeForWrite",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileSystemServer).CreateVolumeForWrite(ctx, req.(*CreateVolumeForWriteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileSystem_CreateFileURI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateFileURIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileSystemServer).CreateFileURI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fs.FileSystem/CreateFileURI",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileSystemServer).CreateFileURI(ctx, req.(*CreateFileURIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileSystem_CreateVolumeForRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVolumeForReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileSystemServer).CreateVolumeForRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fs.FileSystem/CreateVolumeForRead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileSystemServer).CreateVolumeForRead(ctx, req.(*CreateVolumeForReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileSystem_CreateFileView_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateFileViewRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileSystemServer).CreateFileView(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fs.FileSystem/CreateFileView",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileSystemServer).CreateFileView(ctx, req.(*CreateFileViewRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _FileSystem_serviceDesc = grpc.ServiceDesc{
	ServiceName: "fs.FileSystem",
	HandlerType: (*FileSystemServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateVolumeForWrite",
			Handler:    _FileSystem_CreateVolumeForWrite_Handler,
		},
		{
			MethodName: "CreateFileURI",
			Handler:    _FileSystem_CreateFileURI_Handler,
		},
		{
			MethodName: "CreateVolumeForRead",
			Handler:    _FileSystem_CreateVolumeForRead_Handler,
		},
		{
			MethodName: "CreateFileView",
			Handler:    _FileSystem_CreateFileView_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "fs.proto",
}

func (m *CreateVolumeForWriteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateVolumeForWriteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EstimatedCapacity != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFs(dAtA, i, uint64(m.EstimatedCapacity))
	}
	if len(m.NodeName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.NodeName)))
		i += copy(dAtA[i:], m.NodeName)
	}
	if m.Owner != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFs(dAtA, i, uint64(m.Owner.Size()))
		n1, err := m.Owner.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Namespace) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateVolumeForWriteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateVolumeForWriteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VolumeName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.VolumeName)))
		i += copy(dAtA[i:], m.VolumeName)
	}
	if len(m.VolumeClaimName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.VolumeClaimName)))
		i += copy(dAtA[i:], m.VolumeClaimName)
	}
	if len(m.VolumePath) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.VolumePath)))
		i += copy(dAtA[i:], m.VolumePath)
	}
	if len(m.SubPath) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.SubPath)))
		i += copy(dAtA[i:], m.SubPath)
	}
	if len(m.NodeName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.NodeName)))
		i += copy(dAtA[i:], m.NodeName)
	}
	if m.DeleteAfterUse {
		dAtA[i] = 0x30
		i++
		if m.DeleteAfterUse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateFileURIRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateFileURIRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Scheme) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.Scheme)))
		i += copy(dAtA[i:], m.Scheme)
	}
	if len(m.VolumeName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.VolumeName)))
		i += copy(dAtA[i:], m.VolumeName)
	}
	if len(m.VolumeClaimName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.VolumeClaimName)))
		i += copy(dAtA[i:], m.VolumeClaimName)
	}
	if len(m.VolumePath) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.VolumePath)))
		i += copy(dAtA[i:], m.VolumePath)
	}
	if len(m.SubPath) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.SubPath)))
		i += copy(dAtA[i:], m.SubPath)
	}
	if len(m.NodeName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.NodeName)))
		i += copy(dAtA[i:], m.NodeName)
	}
	if len(m.LocalPath) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.LocalPath)))
		i += copy(dAtA[i:], m.LocalPath)
	}
	if m.IsDir {
		dAtA[i] = 0x40
		i++
		if m.IsDir {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateFileURIResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateFileURIResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.URI) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.URI)))
		i += copy(dAtA[i:], m.URI)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateVolumeForReadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateVolumeForReadRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.URI) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.URI)))
		i += copy(dAtA[i:], m.URI)
	}
	if m.Owner != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFs(dAtA, i, uint64(m.Owner.Size()))
		n2, err := m.Owner.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Namespace) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateVolumeForReadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateVolumeForReadResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VolumeName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.VolumeName)))
		i += copy(dAtA[i:], m.VolumeName)
	}
	if len(m.VolumeClaimName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.VolumeClaimName)))
		i += copy(dAtA[i:], m.VolumeClaimName)
	}
	if len(m.VolumePath) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.VolumePath)))
		i += copy(dAtA[i:], m.VolumePath)
	}
	if len(m.SubPath) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.SubPath)))
		i += copy(dAtA[i:], m.SubPath)
	}
	if len(m.NodeName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.NodeName)))
		i += copy(dAtA[i:], m.NodeName)
	}
	if len(m.LocalPath) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.LocalPath)))
		i += copy(dAtA[i:], m.LocalPath)
	}
	if m.IsDir {
		dAtA[i] = 0x38
		i++
		if m.IsDir {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DeleteAfterUse {
		dAtA[i] = 0x40
		i++
		if m.DeleteAfterUse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateFileViewRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateFileViewRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.URI) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.URI)))
		i += copy(dAtA[i:], m.URI)
	}
	if m.Preview {
		dAtA[i] = 0x10
		i++
		if m.Preview {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateFileViewResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateFileViewResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Content) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if len(m.ContentType) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.ContentType)))
		i += copy(dAtA[i:], m.ContentType)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintFs(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CreateVolumeForWriteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EstimatedCapacity != 0 {
		n += 1 + sovFs(uint64(m.EstimatedCapacity))
	}
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	if m.Owner != nil {
		l = m.Owner.Size()
		n += 1 + l + sovFs(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateVolumeForWriteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VolumeName)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	l = len(m.VolumeClaimName)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	l = len(m.VolumePath)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	l = len(m.SubPath)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	if m.DeleteAfterUse {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateFileURIRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Scheme)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	l = len(m.VolumeName)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	l = len(m.VolumeClaimName)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	l = len(m.VolumePath)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	l = len(m.SubPath)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	l = len(m.LocalPath)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	if m.IsDir {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateFileURIResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateVolumeForReadRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	if m.Owner != nil {
		l = m.Owner.Size()
		n += 1 + l + sovFs(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateVolumeForReadResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VolumeName)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	l = len(m.VolumeClaimName)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	l = len(m.VolumePath)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	l = len(m.SubPath)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	l = len(m.LocalPath)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	if m.IsDir {
		n += 2
	}
	if m.DeleteAfterUse {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateFileViewRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	if m.Preview {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateFileViewResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovFs(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozFs(x uint64) (n int) {
	return sovFs(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CreateVolumeForWriteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateVolumeForWriteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateVolumeForWriteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EstimatedCapacity", wireType)
			}
			m.EstimatedCapacity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EstimatedCapacity |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Owner == nil {
				m.Owner = &v1.OwnerReference{}
			}
			if err := m.Owner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateVolumeForWriteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateVolumeForWriteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateVolumeForWriteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeClaimName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeClaimName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteAfterUse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeleteAfterUse = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateFileURIRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateFileURIRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateFileURIRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scheme = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeClaimName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeClaimName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDir", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDir = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateFileURIResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateFileURIResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateFileURIResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateVolumeForReadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateVolumeForReadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateVolumeForReadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Owner == nil {
				m.Owner = &v1.OwnerReference{}
			}
			if err := m.Owner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateVolumeForReadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateVolumeForReadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateVolumeForReadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeClaimName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeClaimName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDir", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDir = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteAfterUse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeleteAfterUse = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateFileViewRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateFileViewRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateFileViewRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Preview", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Preview = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateFileViewResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateFileViewResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateFileViewResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], dAtA[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFs(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFs
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthFs
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowFs
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipFs(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthFs = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFs   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("fs.proto", fileDescriptor_fs_c1d0750a3158d925) }

var fileDescriptor_fs_c1d0750a3158d925 = []byte{
	// 663 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x55, 0xcd, 0x6e, 0xd3, 0x4a,
	0x14, 0xbe, 0x76, 0x9a, 0x9f, 0x9e, 0xde, 0xdb, 0x7b, 0xef, 0x50, 0x2a, 0x63, 0xaa, 0x34, 0xca,
	0x02, 0x05, 0x04, 0xb6, 0x5a, 0xba, 0x60, 0xc1, 0xa6, 0xa4, 0x14, 0x05, 0xa1, 0xb6, 0x72, 0x7f,
	0x10, 0xec, 0x26, 0xee, 0x49, 0xe2, 0xc6, 0xf6, 0x98, 0x99, 0x49, 0xab, 0x6c, 0x79, 0x8a, 0xf2,
	0x46, 0xac, 0x10, 0xbc, 0x01, 0x2a, 0x12, 0xcf, 0x81, 0xfc, 0x97, 0x38, 0xae, 0x53, 0x75, 0xc1,
	0x86, 0x9d, 0xcf, 0x39, 0x3e, 0x9f, 0xcf, 0x77, 0xbe, 0x6f, 0x3c, 0x50, 0xeb, 0x09, 0x23, 0xe0,
	0x4c, 0x32, 0xa2, 0xf6, 0x84, 0xbe, 0x35, 0x7c, 0x26, 0x0c, 0x87, 0x99, 0x34, 0x70, 0x3c, 0x6a,
	0x0f, 0x1c, 0x1f, 0xf9, 0xd8, 0x0c, 0x86, 0xfd, 0x30, 0x21, 0x4c, 0x0f, 0x25, 0x35, 0xcf, 0x37,
	0xcc, 0x3e, 0xfa, 0xc8, 0xa9, 0xc4, 0xd3, 0xb8, 0xb3, 0xf9, 0x4d, 0x81, 0xfb, 0x6d, 0x8e, 0x54,
	0xe2, 0x09, 0x73, 0x47, 0x1e, 0xee, 0x32, 0xfe, 0x96, 0x3b, 0x12, 0x2d, 0xfc, 0x30, 0x42, 0x21,
	0xc9, 0x63, 0xf8, 0xff, 0xa5, 0x90, 0x8e, 0x17, 0xb6, 0xb4, 0x69, 0x40, 0x6d, 0x47, 0x8e, 0x35,
	0xa5, 0xa1, 0xb4, 0x4a, 0xd6, 0xf5, 0x02, 0xd1, 0xa1, 0xb6, 0xc7, 0x4e, 0x71, 0x8f, 0x7a, 0xa8,
	0xa9, 0x0d, 0xa5, 0xb5, 0x68, 0x4d, 0x62, 0xf2, 0x1a, 0xca, 0xfb, 0x17, 0x3e, 0x72, 0xad, 0xd4,
	0x50, 0x5a, 0x4b, 0x9b, 0x5b, 0x46, 0x3c, 0xaf, 0x91, 0x9d, 0xd7, 0x08, 0x86, 0xfd, 0x30, 0x21,
	0x8c, 0x70, 0x5e, 0xe3, 0x7c, 0xc3, 0x88, 0x5a, 0x2c, 0xec, 0x21, 0x47, 0xdf, 0x46, 0x2b, 0x86,
	0x20, 0x6b, 0xb0, 0x18, 0x62, 0x8a, 0x80, 0xda, 0xa8, 0x2d, 0x44, 0x1f, 0x9a, 0x26, 0x9a, 0x3f,
	0x15, 0x58, 0x2b, 0xe6, 0x24, 0x02, 0xe6, 0x0b, 0x24, 0x75, 0x80, 0xb8, 0x12, 0x0d, 0xaa, 0x44,
	0xfd, 0x99, 0x0c, 0x69, 0xc1, 0xbf, 0x71, 0xd4, 0x76, 0xa9, 0xe3, 0x65, 0xd8, 0xe4, 0xd3, 0x53,
	0xa4, 0x03, 0x2a, 0x07, 0x11, 0xb3, 0x09, 0x52, 0x98, 0x21, 0x1a, 0x54, 0x0f, 0x47, 0xdd, 0xa8,
	0x18, 0x8f, 0x99, 0x86, 0x33, 0xab, 0x2a, 0xe7, 0x56, 0xf5, 0x00, 0x96, 0x77, 0xd0, 0x45, 0x89,
	0xdb, 0x3d, 0x89, 0xfc, 0x58, 0xa0, 0x56, 0x69, 0x28, 0xad, 0x9a, 0x95, 0xcb, 0x36, 0x3f, 0xaa,
	0xb0, 0x12, 0x13, 0xdd, 0x75, 0x5c, 0x3c, 0xb6, 0x3a, 0xa9, 0x6a, 0xab, 0x50, 0x39, 0xb4, 0x07,
	0x38, 0x21, 0x97, 0x44, 0x39, 0xe2, 0xea, 0x6d, 0x88, 0x97, 0x6e, 0x43, 0x7c, 0xe1, 0x26, 0xe2,
	0xe5, 0xf9, 0xc4, 0x2b, 0x39, 0xe2, 0x6b, 0xb0, 0xf8, 0x86, 0xd9, 0xd4, 0x8d, 0xfa, 0xaa, 0xb1,
	0xae, 0x93, 0x04, 0x59, 0x81, 0x72, 0x47, 0xec, 0x38, 0x5c, 0xab, 0x45, 0xdb, 0x88, 0x83, 0xe6,
	0x43, 0xb8, 0x9b, 0xdb, 0x41, 0xa2, 0xf2, 0x7f, 0x50, 0x3a, 0xb6, 0x3a, 0xc9, 0x06, 0xc2, 0xc7,
	0xe6, 0xa5, 0x02, 0x7a, 0xce, 0x18, 0x16, 0xd2, 0xd3, 0x74, 0x6b, 0xd7, 0x1a, 0xa6, 0x9e, 0x55,
	0x7f, 0xb3, 0x67, 0x4b, 0x79, 0xcf, 0x7e, 0x52, 0xaf, 0x9d, 0xc3, 0x78, 0xb4, 0x3f, 0xc4, 0xb2,
	0x33, 0xca, 0x55, 0xe6, 0x2a, 0x57, 0xcd, 0x28, 0x57, 0x60, 0xf3, 0x5a, 0xa1, 0xcd, 0xdb, 0x59,
	0x85, 0x4f, 0x1c, 0xbc, 0x98, 0x2f, 0x98, 0x06, 0xd5, 0x03, 0x8e, 0xe7, 0x0e, 0x5e, 0x44, 0xf4,
	0x6b, 0x56, 0x1a, 0x36, 0x8f, 0x60, 0x35, 0x0f, 0x92, 0xac, 0x56, 0x83, 0x6a, 0x9b, 0xf9, 0x12,
	0x7d, 0x19, 0x21, 0xfd, 0x6d, 0xa5, 0x21, 0x69, 0xc0, 0x52, 0xf2, 0x78, 0x34, 0x0e, 0xd2, 0x85,
	0x66, 0x53, 0x9b, 0x5f, 0x54, 0x80, 0x10, 0xf0, 0x70, 0x2c, 0x24, 0x7a, 0xe4, 0x5d, 0x7a, 0x1e,
	0x67, 0x7f, 0x3c, 0x64, 0xdd, 0xe8, 0x09, 0xe3, 0x86, 0xdf, 0xac, 0xde, 0x98, 0xff, 0x42, 0x32,
	0xe5, 0x0e, 0xfc, 0x33, 0x63, 0x73, 0xa2, 0x4d, 0x5b, 0x66, 0x4f, 0xbf, 0x7e, 0xaf, 0xa0, 0x92,
	0xa0, 0x9c, 0xc0, 0x9d, 0x02, 0x97, 0x91, 0x7a, 0xc1, 0xe7, 0x33, 0x27, 0x43, 0x5f, 0x9f, 0x5b,
	0x4f, 0x70, 0x5f, 0xc1, 0xf2, 0xec, 0x76, 0x49, 0x6e, 0x88, 0x8c, 0x6c, 0xba, 0x5e, 0x54, 0x8a,
	0x81, 0x5e, 0x3c, 0xff, 0x7c, 0x55, 0x57, 0xbe, 0x5e, 0xd5, 0x95, 0xef, 0x57, 0x75, 0xe5, 0xf2,
	0x47, 0xfd, 0xaf, 0xf7, 0x8f, 0xfa, 0x8e, 0x1c, 0x8c, 0xba, 0x86, 0xcd, 0x3c, 0x73, 0xdb, 0x3d,
	0xa3, 0x5d, 0xde, 0xd9, 0x37, 0x87, 0x8c, 0xba, 0x67, 0xf4, 0x09, 0x0b, 0xc2, 0xcb, 0x8c, 0xf1,
	0xe8, 0x9e, 0xeb, 0x89, 0x6e, 0x25, 0xba, 0xd4, 0x9e, 0xfe, 0x0a, 0x00, 0x00, 0xff, 0xff, 0x80,
	0x7e, 0x70, 0xdc, 0x1a, 0x07, 0x00, 0x00,
}
