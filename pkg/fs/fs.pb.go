// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: fs.proto

package fs // import "github.com/AljabrIO/koalja-operator/pkg/fs"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import v1 "k8s.io/apimachinery/pkg/apis/meta/v1"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// CreateVolumeForWriteRequest contains arguments for CreateVolumeForWrite.
type CreateVolumeForWriteRequest struct {
	// Estimated capacity (in bytes) of the data that will be written
	EstimatedCapacity int64 `protobuf:"varint,1,opt,name=EstimatedCapacity,proto3" json:"EstimatedCapacity,omitempty"`
	// Name of the Node on which the PV must reside.
	// If not set, a random node is picked.
	NodeName string `protobuf:"bytes,2,opt,name=NodeName,proto3" json:"NodeName,omitempty"`
	// If set and allow, this the PersistentVolume will be owned by this owner reference.
	Owner                *v1.OwnerReference `protobuf:"bytes,3,opt,name=Owner" json:"Owner,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *CreateVolumeForWriteRequest) Reset()         { *m = CreateVolumeForWriteRequest{} }
func (m *CreateVolumeForWriteRequest) String() string { return proto.CompactTextString(m) }
func (*CreateVolumeForWriteRequest) ProtoMessage()    {}
func (*CreateVolumeForWriteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fs_a9ca239c15067fac, []int{0}
}
func (m *CreateVolumeForWriteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateVolumeForWriteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateVolumeForWriteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CreateVolumeForWriteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateVolumeForWriteRequest.Merge(dst, src)
}
func (m *CreateVolumeForWriteRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateVolumeForWriteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateVolumeForWriteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateVolumeForWriteRequest proto.InternalMessageInfo

func (m *CreateVolumeForWriteRequest) GetEstimatedCapacity() int64 {
	if m != nil {
		return m.EstimatedCapacity
	}
	return 0
}

func (m *CreateVolumeForWriteRequest) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *CreateVolumeForWriteRequest) GetOwner() *v1.OwnerReference {
	if m != nil {
		return m.Owner
	}
	return nil
}

// CreateVolumeForWriteResponse contains results for CreateVolumeForWrite.
type CreateVolumeForWriteResponse struct {
	// Name of the created PersistentVolume
	VolumeName string `protobuf:"bytes,1,opt,name=VolumeName,proto3" json:"VolumeName,omitempty"`
	// Name of the Node on which the volume is created
	NodeName string `protobuf:"bytes,2,opt,name=NodeName,proto3" json:"NodeName,omitempty"`
	// If set, the caller must delete the PersistentVolume after use
	DeleteAfterUse       bool     `protobuf:"varint,3,opt,name=DeleteAfterUse,proto3" json:"DeleteAfterUse,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateVolumeForWriteResponse) Reset()         { *m = CreateVolumeForWriteResponse{} }
func (m *CreateVolumeForWriteResponse) String() string { return proto.CompactTextString(m) }
func (*CreateVolumeForWriteResponse) ProtoMessage()    {}
func (*CreateVolumeForWriteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fs_a9ca239c15067fac, []int{1}
}
func (m *CreateVolumeForWriteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateVolumeForWriteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateVolumeForWriteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CreateVolumeForWriteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateVolumeForWriteResponse.Merge(dst, src)
}
func (m *CreateVolumeForWriteResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateVolumeForWriteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateVolumeForWriteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateVolumeForWriteResponse proto.InternalMessageInfo

func (m *CreateVolumeForWriteResponse) GetVolumeName() string {
	if m != nil {
		return m.VolumeName
	}
	return ""
}

func (m *CreateVolumeForWriteResponse) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *CreateVolumeForWriteResponse) GetDeleteAfterUse() bool {
	if m != nil {
		return m.DeleteAfterUse
	}
	return false
}

// CreateFileURIRequest contains arguments for CreateFileURI
type CreateFileURIRequest struct {
	// Name of the PersistentVolume that contains the file/dir
	VolumeName string `protobuf:"bytes,1,opt,name=VolumeName,proto3" json:"VolumeName,omitempty"`
	// Name of the Node on which the volume resides
	NodeName string `protobuf:"bytes,2,opt,name=NodeName,proto3" json:"NodeName,omitempty"`
	// Local path of the file/dir in the PersistentVolume
	LocalPath string `protobuf:"bytes,3,opt,name=LocalPath,proto3" json:"LocalPath,omitempty"`
	// IsDir indicates if the URI is for a file (false) or a directory (true)
	IsDir                bool     `protobuf:"varint,4,opt,name=IsDir,proto3" json:"IsDir,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateFileURIRequest) Reset()         { *m = CreateFileURIRequest{} }
func (m *CreateFileURIRequest) String() string { return proto.CompactTextString(m) }
func (*CreateFileURIRequest) ProtoMessage()    {}
func (*CreateFileURIRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fs_a9ca239c15067fac, []int{2}
}
func (m *CreateFileURIRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateFileURIRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateFileURIRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CreateFileURIRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateFileURIRequest.Merge(dst, src)
}
func (m *CreateFileURIRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateFileURIRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateFileURIRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateFileURIRequest proto.InternalMessageInfo

func (m *CreateFileURIRequest) GetVolumeName() string {
	if m != nil {
		return m.VolumeName
	}
	return ""
}

func (m *CreateFileURIRequest) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *CreateFileURIRequest) GetLocalPath() string {
	if m != nil {
		return m.LocalPath
	}
	return ""
}

func (m *CreateFileURIRequest) GetIsDir() bool {
	if m != nil {
		return m.IsDir
	}
	return false
}

// CreateFileURIRequest contains results for CreateFileURI
type CreateFileURIResponse struct {
	// The created URI
	URI                  string   `protobuf:"bytes,1,opt,name=URI,proto3" json:"URI,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateFileURIResponse) Reset()         { *m = CreateFileURIResponse{} }
func (m *CreateFileURIResponse) String() string { return proto.CompactTextString(m) }
func (*CreateFileURIResponse) ProtoMessage()    {}
func (*CreateFileURIResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fs_a9ca239c15067fac, []int{3}
}
func (m *CreateFileURIResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateFileURIResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateFileURIResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CreateFileURIResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateFileURIResponse.Merge(dst, src)
}
func (m *CreateFileURIResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateFileURIResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateFileURIResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateFileURIResponse proto.InternalMessageInfo

func (m *CreateFileURIResponse) GetURI() string {
	if m != nil {
		return m.URI
	}
	return ""
}

// CreateVolumeForReadRequest contains arguments for CreateVolumeForRead
type CreateVolumeForReadRequest struct {
	// The URI to read
	URI string `protobuf:"bytes,1,opt,name=URI,proto3" json:"URI,omitempty"`
	// If set and allow, this the PersistentVolume will be owned by this owner reference.
	Owner                *v1.OwnerReference `protobuf:"bytes,2,opt,name=Owner" json:"Owner,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *CreateVolumeForReadRequest) Reset()         { *m = CreateVolumeForReadRequest{} }
func (m *CreateVolumeForReadRequest) String() string { return proto.CompactTextString(m) }
func (*CreateVolumeForReadRequest) ProtoMessage()    {}
func (*CreateVolumeForReadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fs_a9ca239c15067fac, []int{4}
}
func (m *CreateVolumeForReadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateVolumeForReadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateVolumeForReadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CreateVolumeForReadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateVolumeForReadRequest.Merge(dst, src)
}
func (m *CreateVolumeForReadRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateVolumeForReadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateVolumeForReadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateVolumeForReadRequest proto.InternalMessageInfo

func (m *CreateVolumeForReadRequest) GetURI() string {
	if m != nil {
		return m.URI
	}
	return ""
}

func (m *CreateVolumeForReadRequest) GetOwner() *v1.OwnerReference {
	if m != nil {
		return m.Owner
	}
	return nil
}

// CreateVolumeForReadResponse contains results for CreateVolumeForRead
type CreateVolumeForReadResponse struct {
	// Name of the created PersistentVolume
	VolumeName string `protobuf:"bytes,1,opt,name=VolumeName,proto3" json:"VolumeName,omitempty"`
	// Name of the Node on which the volume is resides
	NodeName string `protobuf:"bytes,2,opt,name=NodeName,proto3" json:"NodeName,omitempty"`
	// Local path of the file/dir in the PersistentVolume
	LocalPath string `protobuf:"bytes,3,opt,name=LocalPath,proto3" json:"LocalPath,omitempty"`
	// IsDir indicates if the URI is for a file (false) or a directory (true)
	IsDir bool `protobuf:"varint,4,opt,name=IsDir,proto3" json:"IsDir,omitempty"`
	// If set, the caller must delete the PersistentVolume after use
	DeleteAfterUse       bool     `protobuf:"varint,5,opt,name=DeleteAfterUse,proto3" json:"DeleteAfterUse,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateVolumeForReadResponse) Reset()         { *m = CreateVolumeForReadResponse{} }
func (m *CreateVolumeForReadResponse) String() string { return proto.CompactTextString(m) }
func (*CreateVolumeForReadResponse) ProtoMessage()    {}
func (*CreateVolumeForReadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fs_a9ca239c15067fac, []int{5}
}
func (m *CreateVolumeForReadResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateVolumeForReadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateVolumeForReadResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CreateVolumeForReadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateVolumeForReadResponse.Merge(dst, src)
}
func (m *CreateVolumeForReadResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateVolumeForReadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateVolumeForReadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateVolumeForReadResponse proto.InternalMessageInfo

func (m *CreateVolumeForReadResponse) GetVolumeName() string {
	if m != nil {
		return m.VolumeName
	}
	return ""
}

func (m *CreateVolumeForReadResponse) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *CreateVolumeForReadResponse) GetLocalPath() string {
	if m != nil {
		return m.LocalPath
	}
	return ""
}

func (m *CreateVolumeForReadResponse) GetIsDir() bool {
	if m != nil {
		return m.IsDir
	}
	return false
}

func (m *CreateVolumeForReadResponse) GetDeleteAfterUse() bool {
	if m != nil {
		return m.DeleteAfterUse
	}
	return false
}

func init() {
	proto.RegisterType((*CreateVolumeForWriteRequest)(nil), "fs.CreateVolumeForWriteRequest")
	proto.RegisterType((*CreateVolumeForWriteResponse)(nil), "fs.CreateVolumeForWriteResponse")
	proto.RegisterType((*CreateFileURIRequest)(nil), "fs.CreateFileURIRequest")
	proto.RegisterType((*CreateFileURIResponse)(nil), "fs.CreateFileURIResponse")
	proto.RegisterType((*CreateVolumeForReadRequest)(nil), "fs.CreateVolumeForReadRequest")
	proto.RegisterType((*CreateVolumeForReadResponse)(nil), "fs.CreateVolumeForReadResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// FileSystemClient is the client API for FileSystem service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FileSystemClient interface {
	// CreateVolumeForWrite creates a PersistentVolume that can be used to
	// write files to.
	CreateVolumeForWrite(ctx context.Context, in *CreateVolumeForWriteRequest, opts ...grpc.CallOption) (*CreateVolumeForWriteResponse, error)
	// CreateFileURI creates a URI for the given file/dir
	CreateFileURI(ctx context.Context, in *CreateFileURIRequest, opts ...grpc.CallOption) (*CreateFileURIResponse, error)
	// CreateVolumeForRead creates a PersistentVolume for reading a given URI
	CreateVolumeForRead(ctx context.Context, in *CreateVolumeForReadRequest, opts ...grpc.CallOption) (*CreateVolumeForReadResponse, error)
}

type fileSystemClient struct {
	cc *grpc.ClientConn
}

func NewFileSystemClient(cc *grpc.ClientConn) FileSystemClient {
	return &fileSystemClient{cc}
}

func (c *fileSystemClient) CreateVolumeForWrite(ctx context.Context, in *CreateVolumeForWriteRequest, opts ...grpc.CallOption) (*CreateVolumeForWriteResponse, error) {
	out := new(CreateVolumeForWriteResponse)
	err := c.cc.Invoke(ctx, "/fs.FileSystem/CreateVolumeForWrite", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileSystemClient) CreateFileURI(ctx context.Context, in *CreateFileURIRequest, opts ...grpc.CallOption) (*CreateFileURIResponse, error) {
	out := new(CreateFileURIResponse)
	err := c.cc.Invoke(ctx, "/fs.FileSystem/CreateFileURI", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileSystemClient) CreateVolumeForRead(ctx context.Context, in *CreateVolumeForReadRequest, opts ...grpc.CallOption) (*CreateVolumeForReadResponse, error) {
	out := new(CreateVolumeForReadResponse)
	err := c.cc.Invoke(ctx, "/fs.FileSystem/CreateVolumeForRead", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FileSystemServer is the server API for FileSystem service.
type FileSystemServer interface {
	// CreateVolumeForWrite creates a PersistentVolume that can be used to
	// write files to.
	CreateVolumeForWrite(context.Context, *CreateVolumeForWriteRequest) (*CreateVolumeForWriteResponse, error)
	// CreateFileURI creates a URI for the given file/dir
	CreateFileURI(context.Context, *CreateFileURIRequest) (*CreateFileURIResponse, error)
	// CreateVolumeForRead creates a PersistentVolume for reading a given URI
	CreateVolumeForRead(context.Context, *CreateVolumeForReadRequest) (*CreateVolumeForReadResponse, error)
}

func RegisterFileSystemServer(s *grpc.Server, srv FileSystemServer) {
	s.RegisterService(&_FileSystem_serviceDesc, srv)
}

func _FileSystem_CreateVolumeForWrite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVolumeForWriteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileSystemServer).CreateVolumeForWrite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fs.FileSystem/CreateVolumeForWrite",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileSystemServer).CreateVolumeForWrite(ctx, req.(*CreateVolumeForWriteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileSystem_CreateFileURI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateFileURIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileSystemServer).CreateFileURI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fs.FileSystem/CreateFileURI",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileSystemServer).CreateFileURI(ctx, req.(*CreateFileURIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileSystem_CreateVolumeForRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVolumeForReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileSystemServer).CreateVolumeForRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fs.FileSystem/CreateVolumeForRead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileSystemServer).CreateVolumeForRead(ctx, req.(*CreateVolumeForReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _FileSystem_serviceDesc = grpc.ServiceDesc{
	ServiceName: "fs.FileSystem",
	HandlerType: (*FileSystemServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateVolumeForWrite",
			Handler:    _FileSystem_CreateVolumeForWrite_Handler,
		},
		{
			MethodName: "CreateFileURI",
			Handler:    _FileSystem_CreateFileURI_Handler,
		},
		{
			MethodName: "CreateVolumeForRead",
			Handler:    _FileSystem_CreateVolumeForRead_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "fs.proto",
}

func (m *CreateVolumeForWriteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateVolumeForWriteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EstimatedCapacity != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFs(dAtA, i, uint64(m.EstimatedCapacity))
	}
	if len(m.NodeName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.NodeName)))
		i += copy(dAtA[i:], m.NodeName)
	}
	if m.Owner != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFs(dAtA, i, uint64(m.Owner.Size()))
		n1, err := m.Owner.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateVolumeForWriteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateVolumeForWriteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VolumeName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.VolumeName)))
		i += copy(dAtA[i:], m.VolumeName)
	}
	if len(m.NodeName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.NodeName)))
		i += copy(dAtA[i:], m.NodeName)
	}
	if m.DeleteAfterUse {
		dAtA[i] = 0x18
		i++
		if m.DeleteAfterUse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateFileURIRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateFileURIRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VolumeName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.VolumeName)))
		i += copy(dAtA[i:], m.VolumeName)
	}
	if len(m.NodeName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.NodeName)))
		i += copy(dAtA[i:], m.NodeName)
	}
	if len(m.LocalPath) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.LocalPath)))
		i += copy(dAtA[i:], m.LocalPath)
	}
	if m.IsDir {
		dAtA[i] = 0x20
		i++
		if m.IsDir {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateFileURIResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateFileURIResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.URI) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.URI)))
		i += copy(dAtA[i:], m.URI)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateVolumeForReadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateVolumeForReadRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.URI) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.URI)))
		i += copy(dAtA[i:], m.URI)
	}
	if m.Owner != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFs(dAtA, i, uint64(m.Owner.Size()))
		n2, err := m.Owner.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateVolumeForReadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateVolumeForReadResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VolumeName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.VolumeName)))
		i += copy(dAtA[i:], m.VolumeName)
	}
	if len(m.NodeName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.NodeName)))
		i += copy(dAtA[i:], m.NodeName)
	}
	if len(m.LocalPath) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFs(dAtA, i, uint64(len(m.LocalPath)))
		i += copy(dAtA[i:], m.LocalPath)
	}
	if m.IsDir {
		dAtA[i] = 0x20
		i++
		if m.IsDir {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DeleteAfterUse {
		dAtA[i] = 0x28
		i++
		if m.DeleteAfterUse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintFs(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CreateVolumeForWriteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EstimatedCapacity != 0 {
		n += 1 + sovFs(uint64(m.EstimatedCapacity))
	}
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	if m.Owner != nil {
		l = m.Owner.Size()
		n += 1 + l + sovFs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateVolumeForWriteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VolumeName)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	if m.DeleteAfterUse {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateFileURIRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VolumeName)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	l = len(m.LocalPath)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	if m.IsDir {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateFileURIResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateVolumeForReadRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	if m.Owner != nil {
		l = m.Owner.Size()
		n += 1 + l + sovFs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateVolumeForReadResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VolumeName)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	l = len(m.LocalPath)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	if m.IsDir {
		n += 2
	}
	if m.DeleteAfterUse {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovFs(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozFs(x uint64) (n int) {
	return sovFs(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CreateVolumeForWriteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateVolumeForWriteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateVolumeForWriteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EstimatedCapacity", wireType)
			}
			m.EstimatedCapacity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EstimatedCapacity |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Owner == nil {
				m.Owner = &v1.OwnerReference{}
			}
			if err := m.Owner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateVolumeForWriteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateVolumeForWriteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateVolumeForWriteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteAfterUse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeleteAfterUse = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateFileURIRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateFileURIRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateFileURIRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDir", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDir = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateFileURIResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateFileURIResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateFileURIResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateVolumeForReadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateVolumeForReadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateVolumeForReadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Owner == nil {
				m.Owner = &v1.OwnerReference{}
			}
			if err := m.Owner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateVolumeForReadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateVolumeForReadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateVolumeForReadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDir", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDir = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteAfterUse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeleteAfterUse = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFs(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFs
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthFs
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowFs
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipFs(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthFs = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFs   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("fs.proto", fileDescriptor_fs_a9ca239c15067fac) }

var fileDescriptor_fs_a9ca239c15067fac = []byte{
	// 499 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x94, 0xcf, 0x6e, 0xd3, 0x40,
	0x10, 0xc6, 0xd9, 0x84, 0xa0, 0x64, 0x10, 0x08, 0x96, 0x22, 0x05, 0x53, 0xb9, 0x91, 0x0f, 0x28,
	0x20, 0x58, 0xab, 0xa5, 0x07, 0x0e, 0x5c, 0x4a, 0x43, 0xa5, 0x20, 0xd4, 0xa2, 0x45, 0x29, 0x82,
	0xdb, 0xc6, 0x19, 0x27, 0x6e, 0x6c, 0xaf, 0xd9, 0xdd, 0x14, 0x85, 0x23, 0x12, 0x3c, 0x03, 0xef,
	0x81, 0x78, 0x07, 0x8e, 0x3c, 0x02, 0x0a, 0x2f, 0x82, 0x6c, 0x27, 0xe4, 0x9f, 0xdb, 0x03, 0xe5,
	0xe6, 0x9d, 0xd9, 0xd9, 0xf9, 0xe9, 0xfb, 0xc6, 0x03, 0x55, 0x5f, 0xb3, 0x44, 0x49, 0x23, 0x69,
	0xc9, 0xd7, 0xd6, 0xee, 0xf0, 0x89, 0x66, 0x81, 0x74, 0x45, 0x12, 0x44, 0xc2, 0x1b, 0x04, 0x31,
	0xaa, 0xb1, 0x9b, 0x0c, 0xfb, 0x69, 0x40, 0xbb, 0x11, 0x1a, 0xe1, 0x9e, 0x6e, 0xbb, 0x7d, 0x8c,
	0x51, 0x09, 0x83, 0xbd, 0xbc, 0xd2, 0xf9, 0x46, 0xe0, 0xee, 0xbe, 0x42, 0x61, 0xf0, 0x58, 0x86,
	0xa3, 0x08, 0x0f, 0xa4, 0x7a, 0xa3, 0x02, 0x83, 0x1c, 0xdf, 0x8f, 0x50, 0x1b, 0xfa, 0x10, 0x6e,
	0x3e, 0xd7, 0x26, 0x88, 0xd2, 0x92, 0x7d, 0x91, 0x08, 0x2f, 0x30, 0xe3, 0x3a, 0x69, 0x90, 0x66,
	0x99, 0xaf, 0x27, 0xa8, 0x05, 0xd5, 0x43, 0xd9, 0xc3, 0x43, 0x11, 0x61, 0xbd, 0xd4, 0x20, 0xcd,
	0x1a, 0xff, 0x7b, 0xa6, 0x2f, 0xa0, 0x72, 0xf4, 0x21, 0x46, 0x55, 0x2f, 0x37, 0x48, 0xf3, 0xea,
	0xce, 0x2e, 0xcb, 0x79, 0xd9, 0x22, 0x2f, 0x4b, 0x86, 0xfd, 0x34, 0xa0, 0x59, 0xca, 0xcb, 0x4e,
	0xb7, 0x59, 0x56, 0xc2, 0xd1, 0x47, 0x85, 0xb1, 0x87, 0x3c, 0x7f, 0xc2, 0xf9, 0x44, 0x60, 0xb3,
	0x98, 0x5a, 0x27, 0x32, 0xd6, 0x48, 0x6d, 0x80, 0x3c, 0x93, 0xa1, 0x90, 0x0c, 0x65, 0x21, 0x72,
	0x2e, 0xe8, 0x3d, 0xb8, 0xde, 0xc2, 0x10, 0x0d, 0xee, 0xf9, 0x06, 0x55, 0x47, 0x63, 0x46, 0x5c,
	0xe5, 0x2b, 0x51, 0xe7, 0x0b, 0x81, 0x8d, 0x1c, 0xe2, 0x20, 0x08, 0xb1, 0xc3, 0xdb, 0x33, 0xcd,
	0x2e, 0xd2, 0x7c, 0x13, 0x6a, 0x2f, 0xa5, 0x27, 0xc2, 0x57, 0xc2, 0x0c, 0xb2, 0xbe, 0x35, 0x3e,
	0x0f, 0xd0, 0x0d, 0xa8, 0xb4, 0x75, 0x2b, 0x50, 0xf5, 0xcb, 0x19, 0x51, 0x7e, 0x70, 0xee, 0xc3,
	0xed, 0x15, 0x8e, 0xa9, 0x0a, 0x37, 0xa0, 0xdc, 0xe1, 0xed, 0x29, 0x41, 0xfa, 0xe9, 0x7c, 0x04,
	0x6b, 0x45, 0x37, 0x8e, 0xa2, 0x37, 0x03, 0x5f, 0xbb, 0x3f, 0x37, 0xad, 0x74, 0x71, 0xd3, 0xbe,
	0xaf, 0x8f, 0x5a, 0xde, 0xfc, 0x3f, 0x78, 0xf6, 0x0f, 0xb2, 0x15, 0xf8, 0x5c, 0x29, 0xf2, 0x79,
	0xe7, 0x73, 0x09, 0x20, 0x55, 0xf6, 0xf5, 0x58, 0x1b, 0x8c, 0xe8, 0xdb, 0x99, 0xeb, 0xcb, 0xa3,
	0x47, 0xb7, 0x98, 0xaf, 0xd9, 0x39, 0xbf, 0x92, 0xd5, 0x38, 0xfb, 0xc2, 0x54, 0x81, 0x16, 0x5c,
	0x5b, 0x32, 0x92, 0xd6, 0xe7, 0x25, 0xcb, 0x33, 0x66, 0xdd, 0x29, 0xc8, 0x4c, 0x5f, 0x39, 0x86,
	0x5b, 0x05, 0x32, 0x53, 0xbb, 0xa0, 0xfd, 0x82, 0xf9, 0xd6, 0xd6, 0x99, 0xf9, 0xfc, 0xdd, 0x67,
	0x4f, 0x7f, 0x4c, 0x6c, 0xf2, 0x73, 0x62, 0x93, 0x5f, 0x13, 0x9b, 0x7c, 0xfd, 0x6d, 0x5f, 0x7a,
	0xf7, 0xa0, 0x1f, 0x98, 0xc1, 0xa8, 0xcb, 0x3c, 0x19, 0xb9, 0x7b, 0xe1, 0x89, 0xe8, 0xaa, 0xf6,
	0x91, 0x3b, 0x94, 0x22, 0x3c, 0x11, 0x8f, 0x64, 0x92, 0xee, 0x19, 0xa9, 0xb2, 0x15, 0xe4, 0xeb,
	0xee, 0x95, 0x6c, 0xdf, 0x3c, 0xfe, 0x13, 0x00, 0x00, 0xff, 0xff, 0x26, 0x3f, 0x85, 0xe7, 0xb5,
	0x04, 0x00, 0x00,
}
